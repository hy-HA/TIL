# 트랜잭션 개념
- **데이터를 저장할 때 단순히 파일에 저장해도 되는데, 데이터베이스에 저장하는 이유는 무엇일까?** 
- **가장 대표적인 이유는 바로 데이터베이스는 트랜잭션이라는 개념을 지원하기 때문**
## Sample 상황1
- 세션1, 세션2 둘다 가운데 있는 기본 테이블을 조회하면 해당 데이터가 그대로 조회
- 세션1이 신규 데이터 추가(커밋 X)
    - 세션1은 select 쿼리를 실행해서 본인이 입력한 신규 회원1, 신규 회원2를 조회할 수 있다.
    - 세션2는 select 쿼리를 실행해도 신규 회원들을 조회할 수 없다. 
        - 왜냐하면 세션1이 아직 커밋을 하지 않았기 때문
- 커밋하지 않은 데이터를 다른 곳에서 조회할 수 있으면 어떤 문제가 발생할까?
    - `데이터 정합성`에 큰 문제가 발생
        - 세션2에서 세션1이 아직 커밋하지 않은 변경 데이터가 보이다면, 세션1이 롤백 했을 때 심각한 문제가 발생할 수 있다. 
        - 예를 들어서 커밋하지 않는 데이터가 보인다면, 세션2는 데이터를 조회했을 때 신규 회원1, 2가 보일 것이다. 
        - 따라서 신규 회원1, 신규 회원2가 있다고 가정하고 어떤 로직을 수행할 수 있다. 
        - 그런데 세션1이 롤백을 수행하면 신규 회원1, 신규 회원2의 데이터가 사라지게 된다.
## 트랜잭션
- 이름 그대로 번역하면 `거래`라는 뜻
- 데이터베이스에서 트랜잭션은 **하나의 거래를 안전하게 처리하도록 보장**해주는 것

## 트랜잭션 ACID
- 아래 4가지를 보장해야
1. 원자성(Atomicity)
    - 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야 한다.
2. 일관성(Consistency)
    - 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 
    - 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
3. 격리성(Isolation)
    - 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 
    - 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 
    - 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준 (Isolation level)을 선택할 수 있다.
4. 지속성(Durability)
    - 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 
    - 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

## 트랜잭션 격리 수준
- 문제는 격리성인데 트랜잭션 간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 순서대로 실행해야 
- 이렇게 하면 동시 처리 성능이 매우 나빠진다. 
- 이런 문제로 인해 ANSI 표준은 트랜잭션의 격리 수준을 4단계로 나누어 정의했다.
    1. Isolation level READ UNCOMMITED(커밋되지 않은 읽기) 
    2. READ COMMITTED(커밋된 읽기) 
    3. REPEATABLE READ(반복 가능한 읽기) 
    4. SERIALIZABLE(직렬화 가능)

> 참고: 강의에서는 일반적으로 많이 사용하는 READ COMMITTED(커밋된 읽기) 트랜잭션 격리 수준을 기준으로 설명한다.
> 트랜잭션 격리 수준은 데이터베이스에 자체에 관한 부분이어서 이 강의 내용을 넘어선다. 트랜잭션 격리 수준에 대한 더 자세한 내용은 데이터베이스 메뉴얼이나, JPA 책 16.1 트랜잭션과 락을 참고

# 데이터베이스 연결구조와 DB섹션
## 데이터베이스 연결구조

![](https://i.imgur.com/YJmtdfW.png)

- 사용자는 클라이언트를 사용해서 데이터베이스 서버에 접근할 수 있음  
    - 클라이언트 
        - ex) 웹 애플리케이션 서버(WAS)나 DB 접근 툴
        - ex) 스프링부트, H2 콘솔
1. 클라이언트는 데이터베이스 서버에 연결을 요청하고 **커넥션**을 맺음 
2. 이때 데이터베이스 서버는 내부에 **세션**이라는 것을 만든다. 
    - 앞으로 해당 커넥션을 통한 모든 요청은 이 세션을 통해서 실행하게 된다.
3. 개발자가 클라이언트를 통해 **SQL을 전달**하면 현재 커넥션에 연결된 **세션이 SQL을 실행**
4. 세션은 **트랜잭션을 시작하고, 커밋 또는 롤백을 통해 트랜잭션을 종료**한다. 
    - 그리고 이후에 새로운 트랜잭션을 다시 시작할 수 있다.
    - 사용자가 커넥션을 닫거나, 또는 DBA(DB 관리자)가 세션을 강제로 종료하면 세션은 종료된다.

# 자동커밋, 수동커밋
- 자동 커밋으로 설정하면 각각의 쿼리 실행 직후에 자동으로 커밋을 호출한다. 
    - 따라서 커밋이나 롤백을 직접 호출하지 않아도 되는 편리함이 있다. 
    - 하지만 쿼리를 하나하나 실행할 때 마다 자동으로 커밋이 되어버리기 때문에 우리가 원하는 트랜잭션 기능을 제대로 사용할 수 없다.
- 따라서 commit , rollback 을 직접 호출하면서 트랜잭션 기능을 제대로 수행하려면 자동 커밋을 끄고 수동 커밋을 사용해야 한다.
- 보통 자동 커밋 모드가 기본으로 설정된 경우가 많기 때문에, 수동 커밋 모드로 설정하는 것을 트랜잭션을 시작한다고 표현할 수 있다.
- 수동 커밋 설정을 하면 이후에 꼭 commit , rollback 을 호출해야 한다.
- 참고로 수동 커밋 모드나 자동 커밋 모드는 한번 설정하면 해당 세션에서는 계속 유지된다. 중간에 변경하는 것은 가능하다.
- 수동 커밋 설정
```sql
set autocommit false; //수동 커밋 모드 설정
insert into member(member_id, money) values ('data3',10000);
insert into member(member_id, money) values ('data4',10000); commit; //수동 커밋
```

# DB 락 
- 세션1이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데, 세션2에서 동시에 같은 데이터를 수정하게 되면 여러가지 문제가 발생한다. 
- 바로 트랜잭션의 원자성이 깨지는 것이다. 
- 여기에 더해서 세션1이 중간에 롤백을 하게 되면 세션2는 잘못된 데이터를 수정하는 문제가 발생한다.
- 이런 문제를 방지하려면, 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정할 수 없게 막아야 한다.

![](https://i.imgur.com/lALetUK.png)
```sql
SET LOCK_TIMEOUT 60000;
set autocommit false;
update member set money=1000 where member_id = 'memberA';
```
![](https://i.imgur.com/sR74gRC.png)

## 조회와 락
- 데이터를 조회할 때도 락을 획득하고 싶을 때가 있다. 
- 이럴 때는 select for update 구문을 사용하면 된다.
    ```sql
    set autocommit false;
    select * from member where member_id='memberA' for update;
    ```
- 이렇게 하면 세션1이 조회 시점에 락을 가져가버리기 때문에 다른 세션에서 해당 데이터를 변경할 수 없다. 

### 조회 시점에 락이 필요한 경우
- 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야 할 때 사용한다. 
- 예를 들어서 애플리케이션 로직에서 memberA 의 금액을 조회한 다음에 이 금액 정보로 애플리케이션에서 어떤 계산을 수행한다. 
    - 그런데 이 계산이 돈과 관련된 매우 중요한 계산이어서 계산을 완료할 때 까지 memberA 의 금액을 다른곳에서 변경하면 안된다. 
    - 이럴 때 조회 시점에 락을 획득하면 된다.
- ex) 은행 마감시간

