# 01. 구조체와 객체 지향 프로그래밍
# 구조체
- 데이터를 그룹으로 묶어 새로운 데이터형을 만드는 방법
- 이 그룹을 마치 하나의 '변수'처럼 사용

### 구조체의 한계
- 여전히 데이터와 동작이 분리되어 있음
- 어떤 구조체가 어떤 함수랑 연관 있는지 찾기 복잡함

## 사람이 세상을 인지하는 법
- 사람은 세상을 물체(object)의 집합으로 인지
  - 일반적인 이야기 (모든 것을 물체로 보지는 않음)
- object를 프로그래밍에서는 객체 또는 개체라 번역한다
- 물체는 상태를 가질 뿐만 아니라 동작도 할 수 있다.

### 상태와 동작
- 프로그래밍에서 변수는 상태를 저장
- 동작은 함수를 의미
- 즉, 개체란 상태(변수, 데이터) 외에 동작(함수)까지 포함한다.


--- 

# 객체 지향 프로그래밍

- OOP = Objected Oriented Programming = 객체지향 프로그래밍
- 여러가지 프로그래밍 패러다임 중 하나
- 목적 : 사람이 생각하는 방식과 유사하게 프로그래밍 할 수 있도록 하자!
    - 절차지향 프로그래밍이 너무 어렵고 힘들어서 나온 개념
- 프로그램을 구성하는 기본 요소를 객체로 보고 하는 객체들이 서로 상호작용을 하여 프로그램이 돌아가게 만들려는 **노력**
    - 노력인 이유 : 결과적으로 프로그램은 기계에서 돌기 때문에 어떤 프로그램이라도 최종적으로는 절차적으로 돌 수 밖에 없다
- 주요 특징은 ```캡슐화, 상속, 다형성, 추상화```이다. 🧩

### 절차지향 vs 객체지향
- 절차 지향 프로그래밍
    - 시간이나 사건의 흐름에 따른 프로그래밍<br>
    - 일어난다 -> 씻는다 -> 밥을 먹는다 -> 버스를 탄다-> 요금을 지불한다 -> 학교에 도착
- 객체 지향 프로그래밍
    - 학생, 버스, 밥, 학교
    - 먹는다, 탄다, 간다

> 
> ![](https://i.imgur.com/U9MnRjG.png)
> ---
> ![](https://i.imgur.com/vYMn7Jl.png)

<br>
<br>

# 캡슐화

![](https://i.imgur.com/7snf4NQ.png)

- 데이터 구조와 데이터를 다루는 방법들을 결합 시켜 묶는 것
    - 변수와 함수를 하나로 묶는 것을 뜻함
- 내부의 데이터를 외부로부터 보호
    - 접근제어자 (`private`, `default`, `protected`, `public`)
- 접근제어자를 통해 정보은닉을 활용 할 수도 있다
    - 정보은닉 : 객체 안에 있는 데이터를 외부로부터 보호
    - 보호된 정보에 대해서 `getter`, `setter` 메서드를 만들어 접근 가능하게 하곤 한다
- 사용자가 클래스 속을 알 필요가 없음
  - 사용자가 함수 속을 알 필요가 없는 것과 마찬가지
  - 이 개념은 추강화로 이어진다
- 함수를 분리할 때 적용했던 원칙을 클래스에서도 적용할 것
  - 중복된 코드가 있다면 `private` 메서드로 분리
- 실용적인 용도 : 사용자측의 변경 없이 구현부를 변경할 수 있게 해준다

> **접근제어자**
> |접근 제어자|같은 클래스의 멤버|같은 패키지의 멤버|자식 클래스의 멤버| 그 외의 영역 |
> |---|---|---|---|---|
> |public|○|○|○| ○      |
> |protected|○|○|○| X      |
> |default|○|○|X| X      |
> |private|○|X|X| X      |

> **getter/setter**
> 함수를 통한 데이터 접근의 객관적인 장점
> 1. 멤버 변수를 저장하지 않고 필요할 때마다 getter에서 계산 가능
> 2. setter에서 추가적인 로직을 실행할 수 있음
> 3. 상속을 통한 다형성 구현 가능

### Sample Code : 캡슐화
- 숫자를 배열로 가지는 Array클래스
- Array클래스를 생성하면 배열이 생성된다
- 배열의 필드는 사용자가 알지 못한다
- [과제:자바로 ArrayList를 구현](https://hackmd.io/CHDaT0rQSlW1FHh73vDUsA)
```java
public class Array {

    int[] data;
    int size;

    public MyArrayList() {
        data = new Object[10];
        size = 0;
    }   
}

public class Example{
    
    MyArrayList list = new MyArrayList(); 
    //길이가 10인 배열 data를 가지고 있고, size가 0인 배열이 생성된다. 
    
    //메서드(add,gat)등을 쓰면, 해당 배열(data)를 가지고 연산 후 값을 도출할 것.
    //data와 size 필드는 사용자가 알 필요가 없다!!!(캡슐화)
}
```

# 상속
![](https://i.imgur.com/CpXZUSW.png)

- 이미 존재하는 객체를 기반으로 확장된 객체를 만드는 방법
    - 엄밀히 말하면 객체가 아니라 클래스
- 거의 모든 사람이 **OOP 핵심**이라 여기는 특성 🧩
  - 특히, 재사용성이 궁극의 목적이라 신봉하던 시대에 특ㅎ
  - 현재에도 상속을 지원하지 않으면 OO 언어라고 안 보는게 보통
- OOP의 또 다른 매우 중요한 특성인 **다형성의 기반** 🧩
- 한 번에 모든 구체적인 사항을 만들지 말고 **점진적으로 기능을 확장**시켜 나갈 수 있게 해준다🧩
    - 사람에게는 점진적 학습이 가장 효율적이다
- **확장된 객체**🧩
    - 기존의 객체에 속한 데이터와 동작을 모두 물려받음 (유전)
    - 여기에 다른 데이터나 동작을 추가할 수 있음 (진화)
    - 물론 새클래스를 상속해서 또 다른 새 클래스를 만들 수 있음
- 실용적인 용도 : **코드 중복을 막음**🧩
    - 여러 객체에는 공통되는 데이터와 동작을 부모 객체로 만듦
    - 여러 객체는 각각 그 부모 객체를 상속 받음
    - 그 후 자기에게만 필요한 데이터나 동작을 추가

> **super 키워드**
> - super는 현 개체의 부모 부분을 가리킴
> - super() 라고 코드를 작성하면 부모의 생성자를 호출
> - 멤버 변수나 메서드를 호출할 때도 가능


# 다형성
![](https://i.imgur.com/3FdxnE0.png)

- 많은 사람들이 OOP의 핵심이라고 여기는 특징 🧩
- 같은 지시를 내렸는데 다른 종류의 객체가 동작을 달리 하는 것 🧩
    - 같은 지시 : 동일한 함수 시그내처 호출
    - 달리 동작 : 객체의 종류에 따라 실제로 실행되는 함수 구현 코드가 다름
    - 절차적 언어에서 이런 일을 하려면 `if`문을 사용해야 했음
- 어떤 함수 구현이 실행될지는 실행 중에 결정됨
    - 이를 늦은 바인딩이라고 함 (late binding)
    - 일반적인 함수 호출은 이른 바인딩 (컴파일 중에 결정됨)
- 다형성의 혜택을 받으려면 상속 관계가 필요 🧩
    - 부모 객체에서 함수 시그내처를 선언
    - 자식 객체에서 그 함수를 다르게 구현 (overriding🧩)
- 실용적인 용도
    - 다른 종류의 객체를 편하게 저장 및 처리 가능

> **오버라이딩(Overriding)**
> - 하위 클래스가 이미 상위 클래스에 정의된 메서드의 자체 구현을 제공할 수 있도록 하는 기능
> - 오버라이딩 된 메서드를 호출 시 부모 클래스 구현 대신 자식 클래스 구현이 실행된다
> - 하위 클래스 메서드에서 `@Override` 어노테이션을 명시적으로 사용하여 오버라이딩 메서드임을 명시할 수 있다

> **다형성의 장점**
> 
> - 각 자료형의 코드가 클래스 안에 들어가서 캡슐화
> - 유지 보수성 높아짐
> - 새로운 클래스를 추가할 때 클래스 코드만 추가하면 됨
> - 클라이언트가 작성할 코드가 줄어듦
> ![](https://i.imgur.com/n8zb4OO.png)
> 다형성을 통해 조건문의 사용 없이 코드 구현이 가능하다. 그렇기 때문에 조건문을 사용하면 OO가 아니라고 주장하는 사람이 있다. (조건문 대신 모든 것을 다형성으로 바꿔야 한다고 한다) 하지만 다형성이 조건문을 모두 대체하기는 어렵고, 설사 가능하더라고 그렇게 해야할 이유가 없다.

# 추상화
![](https://i.imgur.com/r7MpKBZ.jpg)
- OOP에서 추상화란 어떤 구체적인 것에 직접 손대지 않겠다는 것을 의미
- 객체 속에 있는 실제 데이터나 함수 구현 방법에 종속되지 않겠다는 뜻
- 데이터 추상화
    - 객체 사용 시 그 안에 정확히 어떤 데이터가 있는지 알 필요 없음
    - 객체 안에 있는 데이터에 접근 불가
        - 그 대신 객체의 함수를 통해 접근
    - 즉, 캡슐화는 추상화를 이루는 방법 중 하나
- 실용적인 용도 : 설계와 구현의 분리

> #### 추상 자료형쪽 관점
>
> - 사용자는 클래스를 자료형으로 사용할 수 있음
> - 그 클래스 안에 들어있는 멤버 변수가 정확히 뭔지 몰라도 됨
>
> #### 절차적 데이터 추상화쪽 관점
>
> - 데이터를 직접 조작하는 대신 메서드를 호출
>
> #### 추상화의 단점
>
> - 동작 없이 데이터만 있는 클래스는 쓸데없는 코드만 늘어남
> - 어떻게 추상화를 해야할 지 뚜렷한 객관적 기준이 없음

---

## 예시 코드

**Person.java**
``` java
// 추상화: 일반 개념을 나타내는 추상 클래스 정의
// 캡슐화: 개인 필드와 공용 메서드를 사용하여 데이터에 대한 액세스 제어
abstract class Person {
    protected String name;
    protected int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // 다형성/추상화: 하위 클래스에 의해 구현되는 추상 메서드
    public abstract void speak();
}
```
---
**Korean.java**
```java
// 상속: Person 클래스를 확장하여 보다 구체적인 클래스 생성
class Korean extends Person {
    public Korean(String name, int age) {
        super(name, age);
    }

    // 캡슐화: Korean 클래스에 대한 speak() 메소드 오버라이딩
    @Override
    public void speak() {
        System.out.println("안녕하세요! 저는 한국인입니다.");
    }
}
```
---
**American.java**
```java
// 상속: Person 클래스를 확장하여 보다 구체적인 클래스 생성
class American extends Person {
    public American(String name, int age) {
        super(name, age);
    }

    // : American 클래스에 대한 speak() 메서드 재정의
    @Override
    public void speak() {
        System.out.println("Hello! I am an American.");
    }
}
```
---
**Main.java**
```java
public class Main {
    public static void main(String[] args) {
        Person koreanPerson = new Korean("홍길동", 30);
        Person americanPerson = new American("John til", 25);
        
        List<Person> people = new ArrayList<>();

        people.add(koreanPerson);
        people.add(americanPerson);

        for (Person person : people) {
            System.out.println(person.getName() + " is " + person.getAge() + " years old.");
            person.speak();
        }
    }
}
```