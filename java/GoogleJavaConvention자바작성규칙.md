코딩 컨벤션(Coding Convention) 
- 프로그래머 사이에서 약속한 코드 작성 양식
- 코드의 가독성을 증진시키고,
- 여러명이 협업할 때 일관된 코드 스타일을 유지할 수 있어 중요
### IDE 포맷 기능
- 자바 컨벤션에 맞추어 코드를 수정해주는 것
- 하지만 IDE가 잡아줄 수 있는 건 개행이나 공백 추가 등
    - 단락(paragraph) 의 순서나 변수명 등 까지 수정해주진 않는다.
- 이클립스
    - ctrl + shift + f 
- 인텔리제이
    - ctrl + alt + L
- **그러므로 프로그래머가 코드 작성단계에서 컨벤션을 고려하여 작성해야 함**

### 용어 정리
- 클래스는 일반적인 class 및 Enum, Interface, Annotation type을 총칭
- 멤버는 inner class, field, method, constructor을 의미
- 주석은 구현주석을 의미한다. 문서화 주석은 Java Doc에서 따로 다룬다.

# 소스파일 기본사항
### 파일 이름
- JAVA 파일 이름은 포함된 소스의 최상위 클래스의 이름과 .java 확장자로 구성한다.
### ENCODING
- encoding은 UTF-8이 기본
### 공백문자
- 개행 문자를 제외하고, ASCII 코드 공백문자(0x20)는 소스 파일에서 유일한 공백문자이다. 두가지를 의미하는데
1. String이나 문자 리터럴에서 공백문자는 이스케이프 된다.
2. 탭 문자는 들여쓰기에 사용하지 않는다.
### 이스케이프 되는 특수문자
- \\b, \\t, \\n, \\f, \\r, \\", \\', \\\\ 에 대해선 octal방식( \\012 )이나 유니코드(\\u000a ) 보단 앞의 방식을 사용한다.
### ASCII 코드 외의 문자
- 아스키코드가 아닌 문자는 유니코드 케릭터 ( ∞ )나, 유니코드 이스케이프 ( \\u221e)가 활용된다. 가장 읽기 좋은 방식으로 선택하는 것이 좋다.

# 소스 파일의 구조

### 라이센스
- 있는 경우에 작성
### package 명세
- 보통 화면 최상단에 위치한 package 문
- 패키지 문은 개행하지 않고, 
- 다른 내용에 적용되는 열 제한(최대 100자)는 패키지문에는 적용되지 않는다.(길면 긴대로 적는다.)
### import 문
1. 와일드 카드 (ex. java.util.* 처럼 아스테리스크로 하위 클래스를 다 적용하는 방식)으로는 가져오지 않는다.
    - 이유 1. 중요한 문제는 아니지만, 성능 이슈가 생길 수도 있다. 
        - Wildcard Import 는 컴파일 할 때 실제 클래스를 찾기위해 해당 패키지의 클래스를 전부 탐색하는데, 그 시간이 더 걸리니까. 
        - 하지만 파일 몇개를 탐색한다고 차이가 더 날지 사실 의문이다. 
        - 또한 많은 어플리케이션이 사전에 컴파일된 jar나 war를 사용하는 경우가 많으므로 이 이유는 크게 중요하지 않다.
    - 이유 2. 별도의 두 패키지를 wildcard import 했는데, 두 패키지 모두에 있는 동일한 이름의 클래스를 활용하는 경우이다. 
        - 이 때 참조할 클래스를 결정할 수 없으므로 컴파일 할 수 없는 상황이 발생한다. 
        - 단순히 클래스를 import 했는데 소스코드를 수정해야 하므로 바람직하지 못하다.
2. import 문도 패키지 문과 마찬가지로 길다고 개행하지 않는다. 열제한(최대 100자) 또한 적용하지 않는다.
3. static import 와 non-static import은 따로 모아서 블록을 만든다. 
    - 블록의 순서는 static, non static이다. 
    - 블록 사이에는 1줄의 개행을 넣는다.각 블록 내에서의 정렬순서는 ASCII 코드 정렬순서이다.
- 상위 클래스를 import 할 때 포함되므로 스태틱 inner class를 위해 static import하지 않는다.
### Class 정의
- 소스 내에서 최상위 클래스는 단 하나여야 한다.
- 클래스 멤버들간의 순서는 정답이 없지만, 논리적 순서를 갖추는게 중요하다.
- 비슷한 역할을 하는 메소드 끼리 뭉쳐놓고, 추상화 단계에 따라 배치하자
- overload된 메소드들은 흩어놓지 않는다


# 포맷
### 중괄호 { } (brace)
- 괄호는 if, else, for, do 및 while문에 코드가 없거나 단 하나라도 생략하지 않습니다.
- 여는 중괄호 전에는 개행하지 않는다.
- 여는 중괄호 뒤에서는 개행한다.} 의 경우...
- 닫는 괄호 앞에서 개행한다.
- 닫는 괄호 뒤의 개행은, 중괄호가 끝나거나 생성자, 메소드, 클래스가 끝날 때 개행한다. 그러므로, else나 , 앞에서는 개행하지 않는다.
#### good example
```java
return () -> {
  while (condition()) {
    method();
  }
};

return new MyClass() {
  @Override 
	public void method() {
    if (condition()) {
      try {
        something();
      } catch (ProblemException e) {
        recover();
      }
    } else if (otherCondition()) {
      somethingElse();
    } else {
      lastThing();
    }
  }
};
```

### 비어있는 블록
- 빈 블록은 개행하거나, 개행하지 않거나 상관없다. 하지만 멀티 블록일 경우 개행해주어야 한다.
```java
// 가능
void doNothing() {}

// 가능
void doNothingElse() {
}

// 멀티블록이면 개행해야
try {
  doSomething();
} catch (Exception e) {}
```

### 블록의 들여쓰기
https://sihyung92.oopy.io/af26a1f6-b327-45a6-a72b-c6fcb754e219