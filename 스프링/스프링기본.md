# 회원 도메인 

1. 회원 도메인 설계
2. 회원 도메인 개발
    1. Grade Enum 생성
    2. Member 클래스 생성
        1. 변수(id,name,grade) 선언
        2. 생성자 생성
        3. 게터세터
3. MemberRepository 인터페이스 생성
    1. save(회원저장)기능과 findeNyId(회원조회) 기능 생성
4. MemoryMemberRepository 구현체 생성
    1. 컬렉션 맵으로 생성(?)
    2. override된 기능에 구현 코딩
5. 회원 서비스 인터페이스 생성
    1. 회원가입, 회원조회 기능 생성
        - void join(Member member)
        - Member findMember(Long memberId)
6. 회원 서비으 구현체 클래스 생성
    1. 리포지토리 인터페이스와 구현체 주입(?)
        - private final MemberRepository memberRepository = new MemoryMemberRepository();
        >  의존관계가 인터페이스뿐만 아니라 구현까지 모두 의존하고 있음. OCP의 원칙을 준수하지 못하고 DIP를 잘 지키지 못하고 있음. 
    2. override된 기능에 구현 코딩

# 테스트
1. MemberApp 클래스 생성

# 주문과 할인 도메인

1. 할인정책 인터페이스 생성
    1. 할인 대상 금액 리턴해주는 기능 생성
        - int discount(Member, int price)   
            - Member클래스 임포트
2. 정액할인정책 구현체 생성
    1. override된 기능에 구현 코딩
        - vip면 천원 할인
3. 주문 도메인 생성
    1. 변수( 회원아이디, 상품이름, 상품 가격, 할인가격) 생성
        - 주문했을 때 만들어지는 객체
    2. 생성자 생성
    3. 게터세터
    4. 계산 로직 생성
        - public int calculatePrice() {
            return itemPrice - discountPrice;
        }
    5. toString 생성 
4. 주문서비스 인터페이스
    1. 주문생성 기능
        - Order createOrder(Long memberId, String itemName, int itemPrice);
            - 파라미터는 반환할 값을 위함
5. 주문서비스 구현체 클래스 생성
    1. 리포지토리 할인정책 주입
    2. override한 기능 구현 코딩
# 테스트
1. OrderApp 클래스 생성
- 단위테스트가 중요 : 시간이 절약됨

# 새로운 할인 정책 
1. 정률할인정책 구현체 생성
2. 단위테스트
3. 정액할인정책을 정률할인정책으로 변경
    1. 주문서비스 구현체 클래스에서 '리포지토리 할인정책 주입' 부분 변경
> 주문서비스 클라이언트(orderServiceImpl)은 주문정책 인터페이스(DiscountPolicy)에 의존하면서 구체 클래스(FixDiscountPolicy)에도 의존하고 있음. (DIP위반) 따라서 정액에서 정률로 변경하면 클라이언트 코드에 영향을 주므로 OCP를 위반하게 됨.

# DIP와 OCP에 맞도록 변경
1. 인터페이스에만 의존하도록 변경
    - orderServiceImpl의 리포지토리 할인정책 주입 코드 변경
        - private final DiscountPolicy discountPolicy = new RateDiscountPolicy(); 를 아래처럼 변경
        - private final DiscountPolicy discountPolicy;
            ```
            final이 있으면 생성자를 통해서 할당이 되어야함(?)
            ```
        - 이제 구현체를 생성해야 함. 
        - 일단 생성자 생성해둠
            ```
            public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
                this.memberRepository = memberRepository;
                this.discountPolicy = ciscountPolicy;
            }
            ```
            ```
            public MemberServiceImple(MemberRepository memberRepository) {
                this.memberRepository = memberRepository;
            }
            ```
2. 누군가 대신 인터페이스의 구현체가 생성되도록 설정 (DI)
    1. 구현객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스를 만들자(AppConfig)
        - AppConfig 생성한 객체 인스턴스(MembeServiceImpl,OrderServiceImpl)의 참조를 생성자를 통해 주입함
        1. 멤버서비스 객체 생성하고 리턴값으로 구현체 설정
            ```
            public MemberService memberService() {
                return new MembeServiceImpl(new MemoryMemberRepository);
            }
            ```
            ```
            public OrderService orderService() {
                return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
            }
            ```
3. AppConfig 실행하기
    1. 멤버서비스 객체 생성시 AppConfig 객체에서 불러오기
        ```
        MemberServive memberServive = new MemberServiveInpl();을 아래처럼 변경
        MemberServive memberServive = appConfig.memberServive();
        // appConfig는 멤버서비스impl을 생성하면서 Memory멤버리포지토리를 사용할거라는 것을 주입함
        ```