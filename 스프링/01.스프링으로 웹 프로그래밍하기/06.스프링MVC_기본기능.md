[1. 로깅](#1로깅)
- 별도의 로깅 라이브러리를 사용해서 로그를 출력

[2. 요청 매핑](#2-요청-매핑)
- 요청이 왔을 때 어떤 컨트롤러가 호출이 되야하는지
1. url 매핑
    - @RestController & @RequestMapping
2. HTTP 메서드 매핑 
    - @RequestMapping(value = "/url", method = RequestMethod.GET) 
3. HTTP 메서드 매핑 축약 
    - @GetMapping
4. PathVariable(경로 변수) 사용 
    - @GetMapping("/url/{tomato}") & @PathVariable("tomato")
5. PathVariable 사용 
    - 다중_@GetMapping("/url1/{tomato}/url2/{potato}")
6. 특정 파라미터 조건 매핑 
    - @GetMapping(value = "/url", params = "mode=debug")
7. 특정 헤더 조건 매핑 
    - @GetMapping(value = "/url", headers = "mode=debug")
8. 미디어 타입 조건 매핑 
    - HTTP 요청 Content-Type, consume_@PostMapping(value = "/url", consumes = "application/json")
9. 미디어 타입 조건 매핑 
    - HTTP 요청 Accept, produce_@PostMapping(value = "/url", produces = "text/html")

[3. 요청 매핑 - API](#3-요청-매핑---api)
- HTTP API 별로 "매핑을 어떻게 하는지"
1. 회원 목록 조회: GET /users
    - @GetMapping
2. 회원 등록: POST    /users
    - @PostMapping
3. 회원 조회: GET     /users/{userId}
    - @GetMapping("/{userId}")
4. 회원 수정: PATCH    /users/{userId}
    - @PatchMapping("/{userId}")
5. 회원 삭제: DELETE  /users/{userId}
    - @DeleteMapping("/{userId}")

[4. HTTP 요청 - 기본, 헤더조회](#4-http요청---기본-헤더조회)
- HTTP 요청이 보내는 "데이터들을 스프링 MVC로 어떻게 조회하는지" 알아보자
1. HttpServletRequest
2. HttpServletResponse
3. HttpMethod 
    - HTTP 메서드를 조회
    - org.springframework.http.HttpMethod 
4. Locale 
    - Locale 정보를 조회
5. @RequestHeader MultiValueMap<String, String> headerMap
    - 모든 HTTP 헤더를 MultiValueMap 형식으로 조회
6. @RequestHeader("host") String host
    - 특정 HTTP 헤더를 조회
    - 속성
        - 필수 값 여부: required
        - 기본 값 속성: defaultValue
7. @CookieValue(value = "myCookie", required = false) String cookie
    - 특정 쿠키를 조회
    - 속성
        - 필수 값 여부: required 
        - 기본 값: defaultValue

[5. HTTP 요청 파라미터 (쿼리 파라미터, HTML form) 조회하는 방법](#5-http-요청-파라미터)
1. 스프링으로 요청 파라미터(request parameter)를 조회 - HttpServletRequest가 제공하는 방식
2. 스프링으로 요청 파라미터(request parameter)를 조회 - Post Form 페이지 생성
3. 스프링으로 요청 파라미터(request parameter)를 조회 - @RequestParam
4. 스프링으로 요청 파라미터(request parameter)를 조회 -  (name=xx) 생략 가능
    - @RequestParam 변수명과 HTTP 파라미터 이름이 같은 경우

5. 스프링으로 요청 파라미터(request parameter)를 조회 -  @RequestParam 생략 가능
    - String, int 등의 단순 타입의 경우

6. 스프링으로 요청 파라미터(request parameter)를 조회 - 파라미터 필수 여부 설정
    - @RequestParam(required = true)

7. 스프링으로 요청 파라미터(request parameter)를 조회 - 파라미터에 기본 값 적용 
    - @RequestParam(required = false, defaultValue = "-1")
8. 스프링으로 요청 파라미터(request parameter)를 조회 - Map으로 조회하기 
    - requestParamMap

9. 스프링으로 요청 파라미터(request parameter)를 조회 - @ModelAttribute

[6. HTTP message body (API) 조회하는 방법](#6-http-message-body)
1. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 - 단순한 텍스트_HttpServletRequest & HttpServletResponse
2. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 - 단순한 텍스트_Input, Output 스트림, Reader
3. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 - 단순한 텍스트_HttpEntity - requestBodyStringV3
4. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 - 단순한 텍스트_@RequestBody - requestBodyStringV4
5. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 - JSON_HttpServletRequest & objectMapper
6. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 - JSON_@RequestBody & objectMapper
7. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 - JSON_@RequestBody & HTTP 메시지 컨버터
8. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 - JSON_HttpEntity
9. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 - JSON_@RequestBody & HttpEntity

[7. 스프링(서버)에서 응답 데이터를 만드는 방법](#7-스프링서버에서-응답-데이터를-만드는-방법) 

[8. 요청 매핑 헨들러 어뎁터 구조-requestmappinghandleradapter](#8-요청-매핑-헨들러-어뎁터-구조---requestmappinghandleradapter)

# 스프링MVC_기본기능

# 1.로깅
- 운영 시스템에서는 System.out.println() 같은 시스템 콘솔을 사용해서 필요한 정보를 출력하지 않고, 
- 별도의 로깅 라이브러리를 사용해서 로그를 출력한다.
- 참고로 로그 관련 라이브러리도 많고, 깊게 들어가면 끝이 없기 때문에, 여기서는 최소한의 사용 방법만 알아본다.

## 로깅 라이브러리
- 스프링 부트 라이브러리를 사용하면 스프링 부트 로깅 라이브러리( spring-boot-starter-logging )가 함께 포함된다.
- 스프링 부트 로깅 라이브러리는 기본으로 다음 로깅 라이브러리를 사용한다.
    - SLF4J (인터페이스) - http://www.slf4j.org 
    - Logback (구현체) - http://logback.qos.ch
- 로그 라이브러리는 Logback, Log4J, Log4J2 등 많은데, 그것을 통합해서 인터페이스로 제공하는 것이 바로 SLF4J 라이브러리
    - 쉽게 이야기해서 SLF4J는 인터페이스이고, 그 구현체로 Logback 같은 로그 라이브러리를 선택하면 된다. 
- 실무에서는 스프링 부트가 기본으로 제공하는 Logback을 대부분 사용한다.

## 로그 선언
- private Logger log = LoggerFactory.getLogger(getClass());
- private static final Logger log = LoggerFactory.getLogger(Xxx.class) 
- @Slf4j : 롬복 사용 가능

## 로그 호출
- log.info("hello")
- System.out.println("hello")
- 시스템 콘솔로 직접 출력하는 것 보다 로그를 사용하면 다음과 같은 장점이 있다. 실무에서는 항상 로그를 사용해야 한다.

## LogTestController
```
//@Slf4j
@RestController
public class LogTestController {

    private final Logger log = LoggerFactory.getLogger(getClass());

    @RequestMapping("/log-test")
    public String logTest() {
        String name = "Spring";
        log.trace("trace log={}", name);
        log.debug("debug log={}", name);
        log.info(" info log={}", name);
        log.warn(" warn log={}", name);
        log.error("error log={}", name);

        //로그를 사용하지 않아도 a+b 계산 로직이 먼저 실행됨, 이런 방식으로 사용하면 X 
        log.debug("String concat log=" + name);
        return "ok";
    } 
}
```

## 매핑 정보
- @RestController
    - @Controller 는 반환 값이 String 이면 뷰 이름으로 인식된다. 그래서 뷰를 찾고 뷰가 랜더링 된다. 
    - @RestController 는 반환 값으로 뷰를 찾는 것이 아니라, HTTP 메시지 바디에 바로 입력한다.
    - 따라서 실행 결과로 ok 메세지를 받을 수 있다. @ResponseBody 와 관련이 있는데, 뒤에서 더 자세히 설명한다.

## 테스트
- 로그가 출력되는 포멧 확인
    - 시간, 로그 레벨, 프로세스 ID, 쓰레드 명, 클래스명, 로그 메시지
- 로그 레벨 설정을 변경해서 출력 결과를 보자.
    - LEVEL: TRACE > DEBUG > INFO > WARN > ERROR 
    - 개발 서버는 debug 출력
    - 운영 서버는 info 출력
- @Slf4j 로 변경

## 로그 레벨 설정
```
application.properties>>

#전체 로그 레벨 설정(기본 info) 
logging.level.root=info

#hello.springmvc 패키지와 그 하위 로그 레벨 설정 
logging.level.hello.springmvc=debug
```

## 올바른 로그 사용법
- log.debug("data=" + data)
    - 로그 출력 레벨을 info로 설정해도 해당 코드에 있는 "data="+data가 실제 실행이 되어 버린다.
    - 결과적으로 문자 더하기 연산이 발생한다. 
- log.debug("data={}", data)
    - 로그 출력 레벨을 info로 설정하면 아무일도 발생하지 않는다. 따라서 앞과 같은 의미없는 연산이 발생하지 않는다.

## 로그 사용시 장점
- 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.
- 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고, 운영서버에서는 출력하지 않는 등 로그를 상황에 맞게 조절할 수 있다.
- 시스템 아웃 콘솔에만 출력하는 것이 아니라, 파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다. 
- 특히 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.
- 성능도 일반 System.out보다 좋다. (내부 버퍼링, 멀티 쓰레드 등등) 그래서 실무에서는 꼭 로그를 사용해야

## 더 공부하실 분
- 로그에 대해서 더 자세한 내용은 slf4j, logback을 검색해보자. 
    - SLF4J - http://www.slf4j.org
    - Logback - http://logback.qos.ch
- 스프링 부트가 제공하는 로그 기능은 다음을 참고하자. 
    - https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-logging



# 2. 요청 매핑
- 요청이 왔을 때 어떤 컨트롤러가 호출이 되야하는지

## 1. @RestController & @RequestMapping
```
//(1) @RestController : 반환 값으로 HTTP 메시지 바디에 바로 입력
@RestController                       
public class MappingController {
    
    private Logger log = LoggerFactory.getLogger(getClass());
    
    //(2) @RequestMapping("/hello-basic") : HTTP 모든 메서드 허용 (GET, HEAD, POST, PUT, PATCH, DELETE)
    @RequestMapping("/hello-basic")    
    public String helloBasic() {
        log.info("helloBasic");
        return "ok";
    }
```

## 매핑 정보 - @RestController vs @Controller
- @Controller는 반환 값이 String 이면 뷰 이름으로 인식된다. 그래서 뷰를 찾고 뷰가 랜더링 된다.
- @RestController는 반환 값으로 뷰를 찾는 것이 아니라, HTTP 메시지 바디에 바로 입력한다. 
    - 따라서 실행 결과로 ok 메세지를 받을 수 있다. 
    - @ResponseBody 와 관련이 있는데, 뒤에서 더 자세히 설명
- @RequestMapping("/hello-basic")
    - /hello-basic URL 호출이 오면 이 메서드가 실행되도록 매핑한다.
    - 대부분의 속성을 배열[] 로 제공하므로 다중 설정이 가능하다. {"/hello-basic", "/hello-go"} 
    - Postman으로 테스트 해보자.

## URL끝에 슬래시(/) 유무의 차이
1. 둘다 허용 - 스프링 부트 3.0 이전
    - 다음 두가지 요청은 다른 URL이지만, 스프링은 다음 URL 요청들을 같은 요청으로 매핑한다. 
        - 매핑: /hello-basic
        - URL 요청: /hello-basic , /hello-basic/

2. 다르게 사용 - 스프링 부트 3.0 이후
    - 스프링 부트 3.0 부터는 /hello-basic , /hello-basic/ 는 서로 다른 URL 요청을 사용해야 한다.
        - 기존에는 마지막에 있는 / (slash)를 제거했지만, 
        - 스프링 부트 3.0 부터는 마지막의 / (slash)를 유지한다. 
            - 따라서 다음과 같이 다르게 매핑해서 사용해야 한다.
            - 매핑: /hello-basic URL 요청: /hello-basic
            - 매핑: /hello-basic/ URL 요청: /hello-basic/

## HTTP 메서드 - @RequestMapping
- @RequestMapping 에 method 속성으로 HTTP 메서드를 지정하지 않으면 HTTP 메서드와 무관하게 호출된다.
    - 모두 허용 GET, HEAD, POST, PUT, PATCH, DELETE


## 2. HTTP 메서드 매핑 - @RequestMapping(value = "/url", method = RequestMethod.GET) 

```
//(1) method 특정 HTTP 메서드 요청만 허용 (GET, HEAD, POST, PUT, PATCH, DELETE)
@RequestMapping(value = "/mapping-get-v1", method = RequestMethod.GET) 
public String mappingGetV1() {

    log.info("mappingGetV1");
    return "ok";

}

>> 만약 여기에 POST 요청을 하면 스프링 MVC는 HTTP 405 상태코드(Method Not Allowed)를 반환한다.
```

## 3. HTTP 메서드 매핑 축약 - @GetMapping
- HTTP 메서드를 축약한 애노테이션을 사용하는 것이 더 직관적이다. 
- 코드를 보면 내부에서 @RequestMapping 과 method 를 지정해서 사용하는 것을 확인할 수 있다.
- 편리한 축약 애노테이션 
    - @GetMapping
    - @PostMapping
    - @PutMapping
    - @DeleteMapping
    - @PatchMapping
```
@GetMapping(value = "/mapping-get-v2")
public String mappingGetV2() {

    log.info("mapping-get-v2");
    return "ok";

}
```

## 4. PathVariable(경로 변수) 사용 - @GetMapping("/url/{tomato}") & @PathVariable("tomato")
- 많이 사용됨
- PathVariable(경로 변수)
    - url경로에 어떤 값을 템플릿 형식(```{userId}```)으로 쓸 수 있고 
    - 그 값을 PathVariable(```@PathVariable("userId")```)로 꺼내서 사용할 수 있음

- 최근 HTTP API는 다음과 같이 리소스 경로에 식별자를 넣는 스타일을 선호한다. 
    - /mapping/userA
    - /users/1
- @RequestMapping 은 URL 경로를 템플릿화 할 수 있는데, @PathVariable 을 사용하면 매칭 되는 부분을 편리하게 조회할 수 있다.
    -```"/mapping/{userId}"```
- @PathVariable 의 이름과 파라미터 이름이 같으면 생략할 수 있다.
    ```
    @GetMapping("/mapping/{userId}")
    public String mappingPath(@PathVariable String userId)
    ```
```
@GetMapping("/mapping/{userId}")
public String mappingPath(@PathVariable("userId") String data) {

    log.info("mappingPath userId={}", data);
    return "ok";

}
```

## 5. PathVariable 사용 
## - 다중_@GetMapping("/url1/{tomato}/url2/{potato}") & @PathVariable
- @RequestMapping 은 URL 경로를 템플릿화 할 수 있는데, @PathVariable 을 사용하면 매칭 되는 부분을 편리하게 조회할 수 있다.
- @PathVariable 의 이름과 파라미터 이름이 같으면 생략할 수 있다.
```
@GetMapping("/mapping/users/{userId}/orders/{orderId}")
public String mappingPath(@PathVariable String userId, @PathVariable Long orderId) {
    log.info("mappingPath userId={}, orderId={}", userId, orderId);
    return "ok";
}
```

## 6. 특정 파라미터 조건 매핑 
## - @GetMapping(value = "/url", params = "mode=debug")
- 잘 사용하지는 않는다.
- 특정 파라미터가 있거나 없는 조건을 추가할 수 있다. 

- 파라미터로 추가 매핑
    1. params="mode",     
        - 파라미터에 mode 정보를 전달해야 매핑이 됨
    2. params="!mode"     
        - 파라미터에 mode 정보가 없어야 매핑이 됨
    3. params="mode=debug"
    4. params="mode!=debug" (! = )
    5. params = {"mode=debug","data=good"}

```
@GetMapping(value = "/mapping-param", params = "mode=debug")
public String mappingParam() {

    log.info("mappingParam");
    return "ok";
}
```

## 7. 특정 헤더 조건 매핑 
## - @GetMapping(value = "/url", headers = "mode=debug")
- 파라미터 매핑과 비슷하지만, HTTP 헤더를 사용한다.
- 특정 헤더로 추가 매핑
    1. headers="mode",
    2. headers="!mode"
    3. headers="mode=debug"
    4. headers="mode!=debug" (! = )

- Postman으로 테스트 해야 한다.
```
@GetMapping(value = "/mapping-header", headers = "mode=debug")
public String mappingHeader() {
    log.info("mappingHeader");
    return "ok";
}
```

## 8. 미디어 타입 조건 매핑 
## - HTTP 요청 Content-Type, consume_@PostMapping(value = "/url", consumes = "application/json")

- Content-Type 헤더 기반 추가 매핑 Media Type
    - 요청의 Content-Type이 무엇인지. 
    - consumes : 서버 입장에서는 요청의 Content-Type의 정보를 소비하는 입장.
    1. consumes="application/json"
    2. consumes="!application/json"
    3. consumes="application/*"
    4. consumes="*\/*"
    5. MediaType.APPLICATION_JSON_VALUE

- HTTP 요청의 Content-Type 헤더를 기반으로 미디어 타입으로 매핑한다.
- 만약 맞지 않으면 HTTP 415 상태코드(Unsupported Media Type)을 반환한다.
    ```
    예시) consumes
    consumes = "text/plain"
    consumes = {"text/plain", "application/*"}
    consumes = MediaType.TEXT_PLAIN_VALUE
    ```
```
@PostMapping(value = "/mapping-consume", consumes = "application/json")
public String mappingConsumes() {
    log.info("mappingConsumes");
    return "ok";
}
```
- Postman으로 테스트 해야 한다.

## 9. 미디어 타입 조건 매핑 
## - HTTP 요청 Accept, produce_@PostMapping(value = "/url", produces = "text/html")

- Accept 헤더 기반 Media Type 
    - produce : 컨트롤러가 생산해내는 Content-Type이 무엇인지
    1. produces = "text/html"
    2. produces = "!text/html"
    3. produces = "text/*"
    4. produces = "*\/*"

- HTTP 요청의 Accept 헤더를 기반으로 미디어 타입으로 매핑한다. 
    - 만약 맞지 않으면 HTTP 406 상태코드(Not Acceptable)을 반환한다.
    ```
    예시)

    produces = "text/plain"
    produces = {"text/plain", "application/*"}
    produces = MediaType.TEXT_PLAIN_VALUE
    produces = "text/plain;charset=UTF-8"
    ```
```

@PostMapping(value = "/mapping-produce", produces = "text/html")
public String mappingProduces() {

    log.info("mappingProduces");
    return "ok";

}
```

# 3. 요청 매핑 - API 

- 회원 관리를 HTTP API로 만든다 생각하고 "매핑을 어떻게 하는지" 알아보자.
- (실제 데이터가 넘어가는 부분은 생략하고 URL 매핑만)

## 회원 관리 API
- 회원 목록 조회: GET /users
    - @GetMapping
- 회원 등록: POST    /users
    - @PostMapping
- 회원 조회: GET     /users/{userId}
    - @GetMapping("/{userId}")
- 회원 수정: PATCH    /users/{userId}
    - @PatchMapping("/{userId}")
- 회원 삭제: DELETE  /users/{userId}
    - @DeleteMapping("/{userId}")

## MappingClassController
- /mapping :는 강의의 다른 예제들과 구분하기 위해 사용 
- @RequestMapping("/mapping/users")
    - 클래스 레벨에 매핑 정보를 두면 메서드 레벨에서 해당 정보를 조합해서 사용한다.

## Postman으로 테스트
- 회원 목록 조회: GET /mapping/users
- 회원 등록: POST /mapping/users 
- 회원 조회: GET /mapping/users/id1 
- 회원 수정: PATCH /mapping/users/id1 
- 회원 삭제: DELETE /mapping/users/id1

```
@RestController
@RequestMapping("/mapping/users")
public class MappingClassController {

    //(1) GET /mapping/users
    @GetMapping
    public String users() {
        return "get users";
    }

    //(2) POST /mapping/users
    @PostMapping
    public String addUser() {
        return "post user";
    }

    //(3) GET /mapping/users/{userId}
    @GetMapping("/{userId}")
    public String findUser(@PathVariable String userId) {
        return "get userId=" + userId;
    }

    //(4) PATCH /mapping/users/{userId}
    @PatchMapping("/{userId}")
    public String updateUser(@PathVariable String userId) {
        return "update userId=" + userId;
    }
    
    //(5) DELETE /mapping/users/{userId}
    @DeleteMapping("/{userId}")
    public String deleteUser(@PathVariable String userId) {
        return "delete userId=" + userId;
    }
}
```
  

# 4. HTTP요청 - 기본, 헤더조회
- HTTP 요청이 보내는 "데이터들을 스프링 MVC로 어떻게 조회하는지" 알아보자.
- 애노테이션 기반의 스프링 컨트롤러는 다양한 파라미터를 지원한다.
    - @RequestHeader : 헤더 조회
    - @CookieValue : 쿠키 조회
- 이번 시간에는 "HTTP 헤더 정보를 조회하는 방법"을 알아보자.

```
@Slf4j
@RestController //(1) 뷰를 반환하는게 아닌 http응답에 데이터를 그대로 출력
public class RequestHeaderController {

    @RequestMapping("/headers")
    public String headers(HttpServletRequest request,
                          HttpServletResponse response,
                          HttpMethod httpMethod,      //(2) HTTP 메서드를 조회
                          Locale locale,              //(3) Locale 정보를 조회
                          @RequestHeader MultiValueMap<String, String> headerMap, 
                                                            //(4) 모든 HTTP 헤더를 MultiValueMap 형식으로 조회
                          @RequestHeader("host") String host,  
                                                            //(5) 특정 HTTP 헤더를 조회
                          @CookieValue(value = "myCookie", required = false) String cookie 
                                                            //(6) 특정 쿠키를 조회
                          ){
        log.info("request={}", request);
        log.info("response={}", response);
        log.info("httpMethod={}", httpMethod);
        log.info("locale={}", locale);
        log.info("headerMap={}", headerMap);
        log.info("header host={}", host);
        log.info("myCookie={}", cookie);
        return "ok";
    }
}
```
## HTTP요청 헤더조회
1. HttpServletRequest
2. HttpServletResponse
3. HttpMethod 
    - HTTP 메서드를 조회
    - org.springframework.http.HttpMethod 
4. Locale 
    - Locale 정보를 조회
5. @RequestHeader MultiValueMap<String, String> headerMap
    - 모든 HTTP 헤더를 MultiValueMap 형식으로 조회
6. @RequestHeader("host") String host
    - 특정 HTTP 헤더를 조회
    - 속성
        - 필수 값 여부: required
        - 기본 값 속성: defaultValue
7. @CookieValue(value = "myCookie", required = false) String cookie
    - 특정 쿠키를 조회
    - 속성
        - 필수 값 여부: required 
        - 기본 값: defaultValue

## MultiValueMap
- MAP과 유사한데, 하나의 키에 여러 값을 받을 수 있다.
- HTTP header, HTTP 쿼리 파라미터와 같이 하나의 키에 여러 값을 받을 때 사용한다.
    - keyA=value1&keyA=value2
    ```
    MultiValueMap<String, String> map = new LinkedMultiValueMap();
    map.add("keyA", "value1");
    map.add("keyA", "value2");
    //[value1,value2]
    List<String> values = map.get("keyA");
    ```
## @Slf4j
- 다음 코드를 자동으로 생성해서 로그를 선언해준다. 개발자는 편리하게 log 라고 사용하면 된다. 
```
private static final org.slf4j.Logger log =
org.slf4j.LoggerFactory.getLogger(RequestHeaderController.class);
```

> 참고 - 요청 파라미터
- @Conroller 의 사용 가능한 파라미터 목록은 다음 공식 메뉴얼에서 확인할 수 있다.
- https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-
arguments

> 참고 - 응답 파라미터
- @Conroller 의 사용 가능한 응답 값 목록은 다음 공식 메뉴얼에서 확인할 수 있다.
- https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-
return-types

# 5. HTTP 요청 파라미터 

## 클라이언트에서 서버로 HTTP 요청 메시지를 통해 요청 데이터를 전달할 때는 주로 다음 3가지 방법을 사용
1. GET - 쿼리 파라미터
    - ```/url?username=hello&age=20```
    - 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달 
    - 예) 검색, 필터, 페이징등에서 많이 사용하는 방식

2. POST - HTML Form
    1. content-type: application/x-www-form-urlencoded
    2. 메시지 바디에 쿼리 파리미터 형식으로 전달 username=hello&age=20 
    - 예) 회원 가입, 상품 주문, HTML Form 사용

>  요청 파라미터(request parameter) 조회
- GET 쿼리 파리미터 전송 방식이든, POST HTML Form 전송 방식이든 둘다 형식이 같으므로 구분없이 조회 가능.
- HttpServletRequest 의 ```request.getParameter()```를 사용하여 위 두가지 요청 파라미터를 조회.
3. HTTP message body에 데이터를 직접 담아서 요청 
    - HTTP API에서 주로 사용, JSON, XML, TEXT 
    - 데이터 형식은 주로 JSON 사용
    - POST, PUT, PATCH


## 1. 스프링으로 요청 파라미터(request parameter)를 조회 - HttpServletRequest가 제공하는 방식

- GET 실행
    - http://localhost:8080/request-param-v1?username=hello&age=20
```
@Slf4j
@Controller
public class RequestParamController {

    /**
    * 반환 타입이 없으면서 이렇게 응답에 값을 직접 집어넣으면, view 조회X
    */
    @RequestMapping("/request-param-v1")
    public void requestParamV1(HttpServletRequest request, HttpServletResponse response) 
                                                                        throws IOException {

        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));
        log.info("username={}, age={}", username, age);
        
        response.getWriter().write("ok");
    }
}
```


## 2. 스프링으로 요청 파라미터(request parameter)를 조회 - Post Form 페이지 생성

- 리소스는 /resources/static 아래에 두면 스프링 부트가 자동으로 인식
    - main/resources/static/basic/hello-form.html
- Post Form 실행 
    - http://localhost:8080/basic/hello-form.html
```
<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <form action="/request-param-v1" method="post">
            username: <input type="text" name="username" /> 
            age: <input type="text" name="age" /> 
            <button type="submit">전송</button>
        </form>
    </body>
    </html>
```


## 3. 스프링으로 요청 파라미터(request parameter)를 조회 - @RequestParam
- 스프링이 제공하는 @RequestParam 을 사용하면 요청 파라미터를 매우 편리하게 사용할 수 있다.

- @RequestParam 
    - 파라미터 이름으로 바인딩
    - name(value) 속성이 파라미터 이름으로 사용 
    ```
    @RequestParam("username") String memberName
    =
    request.getParameter("username")
    ```
- @ResponseBody 
    - (클래스에 @Controller가 있으면 뷰 이름을 조회하게 됨) 하지만 이 어노테이션을 사용하면,
    - View 조회를 무시하고, HTTP message body에 직접 해당 내용 입력

```
//(1) @ResponseBody : View 조회를 무시하고, HTTP message body에 직접 해당 내용 입력 
@ResponseBody                                                    
@RequestMapping("/request-param-v2")
public String requestParamV2(   
                    //(2) @RequestParam 사용 :파라미터 이름으로 바인딩
                    @RequestParam("username") String memberName, 
                    @RequestParam("age") int memberAge) {

    log.info("username={}, age={}", memberName, memberAge);
    return "ok";
}
```

## 4. 스프링으로 요청 파라미터(request parameter)를 조회 
## - @RequestParam 변수명과 HTTP 파라미터 이름이 같은 경우 (name=xx) 생략 가능

- HTTP 파라미터 이름이 변수 이름과 같으면 @RequestParam(name="xx") 생략 가능

```
@ResponseBody
@RequestMapping("/request-param-v3")
public String requestParamV3(
                        @RequestParam String username,
                        @RequestParam int age) {
    log.info("username={}, age={}", username, age);
    return "ok";
}
```

## 5. 스프링으로 요청 파라미터(request parameter)를 조회 
## - String, int 등의 단순 타입의 경우 @RequestParam 생략 가능
- String , int , Integer 등의 단순 타입이면 @RequestParam 도 생략 가능
- 이렇게 애노테이션을 완전히 생략해도 되는데, 너무 없는 것도 약간 과하다는 주관적 생각이 있다. 
- @RequestParam 이 있으면 명확하게 요청 파리미터에서 데이터를 읽는 다는 것을 알 수 있다.

> 주의
- @RequestParam 애노테이션을 생략하면 스프링 MVC는 내부에서 required=false 를 적용한다.
- required 옵션은 바로 다음에 설명한다.

```
@ResponseBody
@RequestMapping("/request-param-v4")
public String requestParamV4(String username, int age) {
        
        log.info("username={}, age={}", username, age);
        return "ok";
    }
```

## 6. 스프링으로 요청 파라미터(request parameter)를 조회 
## - 파라미터 필수 여부 설정_@RequestParam(required = true)
- 파라미터 필수 여부
- 기본값이 파라미터 필수( true )이다.

- "/request-param-required"으로 요청시
    - username 이 없으므로 400 예외가 발생한다.

- 주의! "/request-param?username="으로 요청시
    - /request-param?username=
    - 파라미터 이름만 있고 값이 없는 경우 빈문자로 통과

- 주의! @RequestParam(required = false)인 경우
    - null 을 int 에 입력하는 것은 불가능(500 예외 발생)
        - 기본형(primitive)에 null 입력 시 오류 발생
        - @RequestParam(required = false) int age 로 입력 시 오류 발생
    - 따라서 null 을 받을 수 있는 Integer 로 변경하거나, 또는 다음에 나오는 defaultValue 사용
```
@ResponseBody
@RequestMapping("/request-param-required")
public String requestParamRequired(
                        @RequestParam(required = true) String username,
                        @RequestParam(required = false) Integer age) {
        
        log.info("username={}, age={}", username, age);
        return "ok";
}
```

## 7. 스프링으로 요청 파라미터(request parameter)를 조회 
## - 파라미터에 기본 값 적용 - @RequestParam(required = false, defaultValue = "-1")

- 파라미터에 값이 없는 경우 defaultValue 를 사용하면 기본 값을 적용할 수 있다. 
- 이미 기본 값이 있기 때문에 required 는 의미가 없다.
- 참고! defaultValue 는 빈 문자의 경우에도 설정한 기본 값이 적용된다. 
    - "/request-param-default?username="로 요청시 default값이 적용됨

```
@ResponseBody
@RequestMapping("/request-param-default")
public String requestParamDefault(
                        @RequestParam(required = true, defaultValue = "guest") String username,
                        @RequestParam(required = false, defaultValue = "-1") int age) {
        log.info("username={}, age={}", username, age);
        return "ok";
}
```

## 8. 스프링으로 요청 파라미터(request parameter)를 조회 
## - Map으로 조회하기 - requestParamMap
- 파라미터를 Map, MultiValueMap으로 조회할 수 있다.
    - @RequestParam Map
        - Map(key=value)
    - @RequestParam MultiValueMap
        - MultiValueMap(key=[value1, value2, ...] ex) (key=userIds, value=[id1, id2])
    - 파라미터의 값이 1개가 확실하다면 Map 을 사용해도 되지만, 그렇지 않다면 MultiValueMap 을 사용하자.
```
@ResponseBody
@RequestMapping("/request-param-map")
public String requestParamMap(@RequestParam Map<String, Object> paramMap) {

    log.info("username={}, age={}", paramMap.get("username"), paramMap.get("age"));
    return "ok";
}
```

## 9. 스프링으로 요청 파라미터(request parameter)를 조회 
## - @ModelAttribute

- 실제 개발을 하면 요청 파라미터를 받아서 필요한 객체를 만들고 그 객체에 값을 넣어주어야 한다. 
- 보통 다음과 같이 코드를 작성할 것이다.
```
@RequestParam String username;
@RequestParam int age;

HelloData data = new HelloData();   //@ModelAttribute가 다 함
data.setUsername(username);         //@ModelAttribute가 다 함
data.setAge(age);                   //@ModelAttribute가 다 함
```
- 스프링은 이 과정을 완전히 자동화해주는 @ModelAttribute 기능을 제공한다. 
- 먼저 요청 파라미터를 바인딩 받을 객체를 만들자.

```
@Data
public class HelloData {
    private String username;
    private int age;
  }
```
- 롬복 @Data
    - @Getter , @Setter , @ToString , @EqualsAndHashCode , @RequiredArgsConstructor 를 자동으로 적용해준다.

1. @ModelAttribute 적용 - modelAttributeV1
    - 스프링MVC는 @ModelAttribute 가 있으면 다음을 실행한다. 
        1. HelloData 객체를 생성한다.
        2. 요청 파라미터의 이름으로 HelloData 객체의 프로퍼티(게터,세터)를 찾는다. 
        3. 그리고 해당 프로퍼티의 setter를 호출해서 파라미터의 값을 입력(바인딩) 한다.
        - 예) 파라미터 이름이 username 이면 setUsername() 메서드를 찾아서 호출하면서 값을 입력한다.

    ```
    @ResponseBody
    @RequestMapping("/model-attribute-v1")
    public String modelAttributeV1(@ModelAttribute HelloData helloData) {

        log.info("username={}, age={}", helloData.getUsername(),
    helloData.getAge());
        return "ok";
    }

    >> 마치 마법처럼 HelloData 객체가 생성되고, 요청 파라미터의 값도 모두 들어가 있다.
    ```
    > 참고

    - ```프로퍼티```
        - 객체에 getUsername() , setUsername() 메서드가 있으면, 이 객체는 username 이라는 프로퍼티를 가지고 있다.
        - username 프로퍼티의 값을 변경하면 setUsername() 이 호출되고, 조회하면 getUsername() 이 호출된다.
        - getXxx -> xxx , setXxx -> xxx로 변경
            ```
            class HelloData {
                getUsername();
                setUsername();
            }
            ```

    - ```바인딩 오류```
        - age=abc 처럼 숫자가 들어가야 할 곳에 문자를 넣으면 BindException 이 발생한다. 
        - 이런 바인딩 오류를 처리하는 방법은 검증 부분에서 다룬다.


2. @ModelAttribute 생략 - modelAttributeV2
    - @ModelAttribute 는 생략할 수 있다.
    - 그런데 @RequestParam 도 생략할 수 있으니 혼란이 발생할 수 있다.
    ```
    @ResponseBody
    @RequestMapping("/model-attribute-v2")
    public String modelAttributeV2(HelloData helloData) {
        log.info("username={}, age={}", helloData.getUsername(),
    helloData.getAge());
        return "ok";
    }
    ```

    - 스프링은 해당 생략시 다음과 같은 규칙을 적용한다.
        - String , int , Integer 같은 단순 타입 = @RequestParam
        - 나머지 = @ModelAttribute (argument resolver 로 지정해둔 타입 외) 
            - argument resolver는 뒤에서 학습 예정

# 6. HTTP message body
- 요청 파라미터와 다르게, HTTP 메시지 바디를 통해 데이터가 직접 넘어오는 경우는 @RequestParam , @ModelAttribute 를 사용할 수 없다. 
    - 물론 HTML Form형식으로 전달되는 경우는 요청 파라미터로 인정됨.

## 클라이언트에서 서버로 HTTP 요청 메시지를 통해 요청 데이터를 전달할 때는 주로 다음 3가지 방법을 사용
1. GET - 쿼리 파라미터
    - ```/url?username=hello&age=20```
    - 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달 
    - 예) 검색, 필터, 페이징등에서 많이 사용하는 방식

2. POST - HTML Form
    1. content-type: application/x-www-form-urlencoded
    2. 메시지 바디에 쿼리 파리미터 형식으로 전달 username=hello&age=20 
    - 예) 회원 가입, 상품 주문, HTML Form 사용

>  요청 파라미터(request parameter) 조회
- GET 쿼리 파리미터 전송 방식이든, POST HTML Form 전송 방식이든 둘다 형식이 같으므로 구분없이 조회 가능.
- HttpServletRequest 의 ```request.getParameter()```를 사용하여 위 두가지 요청 파라미터를 조회.

3. HTTP message body에 데이터를 직접 담아서 요청 
    - HTTP API에서 주로 사용, JSON, XML, TEXT 
    - 데이터 형식은 주로 JSON 사용
    - POST, PUT, PATCH

## 데이터를 HTTP 메시지 바디에 담아서 전송&조회 

## 1. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 
## - 단순한 텍스트_HttpServletRequest & HttpServletResponse
```
@Slf4j
@Controller
public class RequestBodyStringController {

    @PostMapping("/request-body-string-v1")
    public void requestBodyString(HttpServletRequest request, HttpServletResponse response) 
                                                                        throws IOException {

        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("messageBody={}", messageBody);
        
        response.getWriter().write("ok");
} }
```
- Postman을 사용해서 테스트 해보자.
    - POST http://localhost:8080/request-body-string-v1 Body row, Text 선택


## 2. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 
## - 단순한 텍스트 메시지_Input, Output 스트림, Reader
- 스프링 MVC는 다음 파라미터를 지원한다.
    1. InputStream(Reader)
        - HTTP 요청 메시지 바디의 내용을 직접 조회 
    2. OutputStream(Writer)
        - HTTP 응답 메시지의 바디에 직접 결과 출력
```
@PostMapping("/request-body-string-v2")
public void requestBodyStringV2(InputStream inputStream, Writer responseWriter) throws IOException {
    
    String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);
    
    log.info("messageBody={}", messageBody);
    
    responseWriter.write("ok");
}
```

## 3. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 
## - 단순한 텍스트 메시지_HttpEntity - requestBodyStringV3

- 스프링 MVC는 다음 파라미터를 지원한다.
    1. HttpEntity: HTTP header, body 정보를 편리하게 조회
        - 메시지 바디 정보를 직접 조회
        - 요청 파라미터를 조회하는 기능과 관계 없음 
            - @RequestParam X, @ModelAttribute X 
    2. HttpEntity는 응답에도 사용 가능
        - 메시지 바디 정보 직접 반환 헤더 정보 포함 가능
        - view 조회X
```
@PostMapping("/request-body-string-v3")
public HttpEntity<String> requestBodyStringV3(HttpEntity<String> httpEntity) {

    String messageBody = httpEntity.getBody();
    log.info("messageBody={}", messageBody);
    
    return new HttpEntity<>("ok");
}
```

- HttpEntity 를 상속받은 다음 객체들도 같은 기능을 제공한다. 
    - RequestEntity
        - HttpMethod, url 정보가 추가, 요청에서 사용 
    - ResponseEntity
        - HTTP 상태 코드 설정 가능, 응답에서 사용
        - return new ResponseEntity<String>("Hello World", responseHeaders, HttpStatus.CREATED)

> 참고
- 스프링MVC 내부에서 HTTP 메시지 바디를 읽어서 문자나 객체로 변환해서 전달해주는데, 
- 이때 HTTP 메시지 컨버터( HttpMessageConverter )라는 기능을 사용한다. 
- 이것은 조금 뒤에 HTTP 메시지 컨버터에서 자세히 설명한다.

## 4. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 
## - 단순한 텍스트 메시지_@RequestBody - requestBodyStringV4

1. @RequestBody
    - @RequestBody 를 사용하면 HTTP 메시지 바디 정보를 편리하게 조회할 수 있다. 
        - 참고로 헤더 정보가 필요하다면 HttpEntity 를 사용하거나 @RequestHeader 를 사용하면 된다.
    - 이렇게 메시지 바디를 직접 조회하는 기능은 요청 파라미터를 조회하는 @RequestParam , @ModelAttribute 와는 전혀 관계가 없다.
2. @ResponseBody
    - @ResponseBody 를 사용하면 응답 결과를 HTTP 메시지 바디에 직접 담아서 전달할 수 있다. 
    - 물론 이 경우에도 view를 사용하지 않는다.


> 요청 파라미터 vs HTTP 메시지 바디
1. 요청 파라미터를 조회하는 기능
    - @RequestParam , @ModelAttribute 
2. HTTP 메시지 바디를 직접 조회하는 기능
    - @RequestBody

```
@ResponseBody
@PostMapping("/request-body-string-v4")
public String requestBodyStringV4(@RequestBody String messageBody) {

    log.info("messageBody={}", messageBody);
    return "ok";
}
```

## 데이터를 HTTP 메시지 바디에 담아서 전송&조회 - JSON
- 이번에는 HTTP API에서 주로 사용하는 JSON 데이터 형식을 조회해보자.

## 5. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 
## - JSON_HttpServletRequest & objectMapper

- HttpServletRequest를 사용해서 직접 HTTP 메시지 바디에서 데이터를 읽어와서, 문자로 변환
- 문자로 된 JSON 데이터를 Jackson 라이브러리인 objectMapper 를 사용해서 자바 객체로 변환
```
/**
* {"username":"hello", "age":20}
* content-type: application/json
*/
@Slf4j
@Controller
public class RequestBodyJsonController {

    private ObjectMapper objectMapper = new ObjectMapper();
    
    @PostMapping("/request-body-json-v1")
    public void requestBodyJsonV1(HttpServletRequest request, HttpServletResponse response) 
                                                                            throws IOException {

        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        log.info("messageBody={}", messageBody);
        HelloData data = objectMapper.readValue(messageBody, HelloData.class);
        log.info("username={}, age={}", data.getUsername(), data.getAge());

        response.getWriter().write("ok");
    }
}
```

- Postman으로 테스트
    - POST http://localhost:8080/request-body-json-v1 
    - raw, JSON, content-type: application/json
    - {"username":"hello", "age":20}


## 6. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 
## - JSON_@RequestBody & objectMapper
1. @RequestBody 를 사용해서 HTTP 메시지에서 데이터를 꺼내고 messageBody에 저장
    - @RequestBody
        - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
2. @ResponseBody
    - 모든 메서드에 @ResponseBody 적용
    - 메시지 바디 정보 직접 반환(view 조회X)
    - HttpMessageConverter 사용 -> StringHttpMessageConverter 적용
3. 문자로 된 JSON 데이터인 messageBody 를 objectMapper 를 통해서 자바 객체로 변환한다.


```
@ResponseBody
@PostMapping("/request-body-json-v2")
public String requestBodyJsonV2(@RequestBody String messageBody) throws IOException {

    HelloData data = objectMapper.readValue(messageBody, HelloData.class);
    log.info("username={}, age={}", data.getUsername(), data.getAge());
    return "ok";
}
```

- 문자로 변환하고 다시 json으로 변환하는 과정이 불편하다. @ModelAttribute처럼 한번에 객체로 변환할 수는 없을까?


## 7. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 
## - JSON_@RequestBody & HTTP 메시지 컨버터
1. @RequestBody 객체 파라미터
    - @RequestBody HelloData data
    - @RequestBody 에 직접 만든 객체를 지정할 수 있다.
    - HttpMessageConverter 사용 -> MappingJackson2HttpMessageConverter (content-type: application/json)
2. 주의
    - @RequestBody 생략 불가능(@ModelAttribute 가 적용되어 버림)

> 참고 - HTTP 메시지 컨버터
- HttpEntity , @RequestBody 를 사용하면 HTTP 메시지 컨버터가 HTTP 메시지 바디의 내용을 우리가 원하는 문자나 객체 등으로 변환해준다.
- HTTP 메시지 컨버터는 문자 뿐만 아니라 JSON도 객체로 변환해주는데, 우리가 방금 V2에서 했던 작업을 대신 처리해준다.
- 자세한 내용은 뒤에 HTTP 메시지 컨버터에서 다룬다. 

```
@ResponseBody
@PostMapping("/request-body-json-v3")
public String requestBodyJsonV3(@RequestBody HelloData data) {

    log.info("username={}, age={}", data.getUsername(), data.getAge());
    return "ok";
}
```

> 참고 -  @RequestBody는 생략 불가능
- @ModelAttribute 에서 학습한 내용을 떠올려보자.
- 스프링은 @ModelAttribute , @RequestParam 과 같은 해당 애노테이션을 생략시 다음과 같은 규칙을 적용한다.
    - String , int , Integer 같은 단순 타입 = @RequestParam
    - 나머지 = @ModelAttribute (argument resolver 로 지정해둔 타입 외)
- 따라서 이 경우 HelloData에 @RequestBody 를 생략하면 @ModelAttribute 가 적용되어버린다. 
    - HelloData data @ModelAttribute HelloData data
- 따라서 생략하면 HTTP 메시지 바디가 아니라 요청 파라미터를 처리하게 된다.

> 주의
- HTTP 요청시에 content-type이 application/json인지 꼭! 확인해야 한다. 
    - 그래야 JSON을 처리할 수 있는 HTTP 메시지 컨버터가 실행된다.

## 8. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 
## - JSON_HttpEntity
```
@ResponseBody
@PostMapping("/request-body-json-v4")
public String requestBodyJsonV4(HttpEntity<HelloData> httpEntity) {
    
    HelloData data = httpEntity.getBody();
    log.info("username={}, age={}", data.getUsername(), data.getAge());
    return "ok";
}

```

## 9. 데이터를 HTTP 메시지 바디에 담아서 전송&조회 
## - JSON_@RequestBody & HttpEntity

- @ResponseBody
    - 응답의 경우에도 @ResponseBody 를 사용하면 해당 객체를 HTTP 메시지 바디에 직접 넣어줄 수 있다.
    - 물론 이 경우에도 HttpEntity 를 사용해도 된다.
    - 메시지 바디 정보 직접 반환(view 조회X)
    - HttpMessageConverter 사용 -> MappingJackson2HttpMessageConverter 적용 
        - (Accept: application/json)
- @RequestBody 요청
    - JSON 요청 ->  HTTP 메시지 컨버터 실행 -> 객체(data)로 받음
    - @RequestBody 생략 불가능(@ModelAttribute 가 적용되어 버림)
    - HttpMessageConverter 사용 -> MappingJackson2HttpMessageConverter 
        - (content-type: application/json)
- @ResponseBody 응답
    - 객체 -> HTTP 메시지 컨버터 실행 -> JSON 응답

```
@ResponseBody
@PostMapping("/request-body-json-v5")
public HelloData requestBodyJsonV5(@RequestBody HelloData data) {

    log.info("username={}, age={}", data.getUsername(), data.getAge());
    return data;
}
```

# 7. 스프링(서버)에서 응답 데이터를 만드는 방법

1. 정적 리소스
    - 예) 웹 브라우저에 정적인 HTML, css, js를 제공할 때는, 정적 리소스를 사용한다.
2. 뷰 템플릿 사용
    - 예) 웹 브라우저에 동적인 HTML을 제공할 때는 뷰 템플릿을 사용한다.
3. HTTP 메시지 사용
    - HTTP API를 제공하는 경우에는 HTML이 아니라 데이터를 전달해야 하므로, 
    - HTTP 메시지 바디에 JSON 같은 형식으로 데이터를 실어 보낸다.

## 1. 정적 리소스
- 정적 리소스는 해당 파일을 변경 없이 그대로 서비스하는 것이다.

- 스프링 부트는 클래스패스의 다음 디렉토리에 있는 정적 리소스를 제공한다. 
    - /static , /public , /resources , /META-INF/resources
        - src/main/resources 는 리소스를 보관하는 곳이고, 또 클래스패스의 시작 경로이다. 
        
- 따라서 다음 디렉토리에 리소스를 넣어두면 스프링 부트가 정적 리소스로 서비스를 제공한다.
    - 정적 리소스 경로
        - src/main/resources/static

- 다음 경로에 파일이 들어있으면 웹 브라우저에서 아래와 같이 실행하면 된다. 
    - 파일 경로 : src/main/resources/static/basic/hello-form.html
    - 파일 실행 url : http://localhost:8080/basic/hello-form.html

## 2. 뷰 템플릿
- 뷰 템플릿을 거쳐서 HTML이 생성되고, 뷰가 응답을 만들어서 전달한다.
- 일반적으로 HTML을 동적으로 생성하는 용도로 사용하지만, 다른 것들도 가능하다. 
- 뷰 템플릿이 만들 수 있는 것이라면 뭐든지 가능하다.

- 스프링 부트는 기본 뷰 템플릿 경로를 제공한다. 

- 뷰 템플릿 경로
    - src/main/resources/templates
- 뷰 템플릿 생성
    - src/main/resources/templates/response/hello.html

    ```
    <!DOCTYPE html>
    <html xmlns:th="http://www.thymeleaf.org">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
    <p th:text="${data}">empty</p>
    </body>
    </html>
    ```
- 뷰 템플릿을 호출하는 컨트롤러
```
@Controller
public class ResponseViewController {

    @RequestMapping("/response-view-v1")
    public ModelAndView responseViewV1() {
    
        ModelAndView mav = new ModelAndView("response/hello")
            .addObject("data", "hello!");

        return mav; 
    }

    //(1) @ResponseBody 가 없으므로 뷰의 논리 이름인 response/hello 를 반환하면 다음 경로의 뷰 템플릿이 렌더링 됨
    @RequestMapping("/response-view-v2")
    public String responseViewV2(Model model) {
    
        model.addAttribute("data", "hello!!");
        return "response/hello";
    }
    
    //(2) 권장하지 않음
    @RequestMapping("/response/hello")
    public void responseViewV3(Model model) {
    
        model.addAttribute("data", "hello!!");
    }
}
```
1. String을 반환하는 경우 - View or HTTP 메시지
    - @ResponseBody 가 없으면 response/hello 로 뷰 리졸버가 실행되어서 뷰를 찾고, 렌더링 한다. 
    - @ResponseBody 가 있으면 뷰 리졸버를 실행하지 않고, HTTP 메시지 바디에 직접 response/hello 라는 문자가 입력된다.
    - 여기서는 뷰의 논리 이름인 'response/hello'을 반환하면 다음 경로의 뷰 템플릿이 렌더링 됨
        - templates/response/hello.html

2. Void를 반환하는 경우
    - @Controller 를 사용하고, 
    - HttpServletResponse , OutputStream(Writer) 같은 HTTP 메시지 바디를 처리하는 파라미터가 없으면 요청 URL을 참고해서 논리 뷰 이름으로 사용 
        - 요청 URL: /response/hello
        - 실행: templates/response/hello.html
    - 참고로 이 방식은 명시성이 너무 떨어지고 이렇게 딱 맞는 경우도 많이 없어서, 권장하지 않는다.

3. HTTP 메시지
    - @ResponseBody , HttpEntity 를 사용하면, 뷰 템플릿을 사용하는 것이 아니라, HTTP 메시지 바디에 직접 응답 데이터를 출력할 수 있다.

## 3. HTTP 메시지 사용
- HTTP API를 제공하는 경우에는 HTML이 아니라 데이터를 전달해야 하므로, HTTP 메시지 바디에 JSON 같은 형식으로 데이터를 실어 보낸다.
- HTTP 요청에서 응답까지 대부분 다루었으므로 이번시간에는 정리를 해보자.

> 참고
-  HTML이나 뷰 템플릿을 사용해도 HTTP 응답 메시지 바디에 HTML 데이터가 담겨서 전달된다. 
- 여기서 설명하는 내용은 정적 리소스나 뷰 템플릿을 거치지 않고, 직접 HTTP 응답 메시지를 전달하는 경우를 말한다.

```
@Slf4j
//@Controller
//@ResponseBody
@RestController   //@Controller + @ResponseBody
public class ResponseBodyController {

    //(1) 문자처리 - 가장 단순한 방식
    @GetMapping("/response-body-string-v1")
    public void responseBodyV1(HttpServletResponse response) throws IOException {
        response.getWriter().write("ok");
    }

    //(2) 문자처리 - HttpEntity, ResponseEntity(Http Status 추가) & @return
    @GetMapping("/response-body-string-v2")
    public ResponseEntity<String> responseBodyV2() {
        return new ResponseEntity<>("ok", HttpStatus.OK);
    }

    //(3) 문자처리 - @ResponseBody
//    @ResponseBody
    @GetMapping("/response-body-string-v3")
    public String responseBodyV3() {
        return "ok";
    }

    //(4) JSON 처리 - ResponseEntity
    @GetMapping("/response-body-json-v1")
    public ResponseEntity<HelloData> responseBodyJsonV1() {
        HelloData helloData = new HelloData();
        helloData.setUsername("userA");
        helloData.setAge(20);
               
        return new ResponseEntity<>(helloData, HttpStatus.OK);
    }

    //(5) JSON 처리 - @ResponseBody
    @ResponseStatus(HttpStatus.OK)
//    @ResponseBody
    @GetMapping("/response-body-json-v2")
    public HelloData responseBodyJsonV2() {
        HelloData helloData = new HelloData();
        helloData.setUsername("userA");
        helloData.setAge(20);
        return helloData;
    }
}

```

1. responseBodyV1
    - 서블릿을 직접 다룰 때 처럼
    - HttpServletResponse 객체를 통해서 HTTP 메시지 바디에 직접 ok 응답 메시지를 전달한다.
    - response.getWriter().write("ok")

2. responseBodyV2
    - ResponseEntity 엔티티는 HttpEntity 를 상속 받았는데, HttpEntity는 HTTP 메시지의 헤더, 바디 정보를 가지고 있다. 
    - ResponseEntity 는 여기에 더해서 HTTP 응답 코드를 설정할 수 있다.
    - HttpStatus.CREATED 로 변경하면 201 응답이 나가는 것을 확인할 수 있다.

3. responseBodyV3
    - @ResponseBody 를 사용하면 view를 사용하지 않고, HTTP 메시지 컨버터를 통해서 HTTP 메시지를 직접 입력할 수 있다. 
    - ResponseEntity 도 동일한 방식으로 동작한다.

4. responseBodyJsonV1
    - ResponseEntity 를 반환한다. HTTP 메시지 컨버터를 통해서 JSON 형식으로 변환되어서 반환된다.

5. responseBodyJsonV2
    - ResponseEntity 는 HTTP 응답 코드를 설정할 수 있는데, @ResponseBody 를 사용하면 이런 것을 설정하기 까다롭다.
    - @ResponseStatus(HttpStatus.OK) 애노테이션을 사용하면 응답 코드도 설정할 수 있다.
    - 물론 애노테이션이기 때문에 응답 코드를 동적으로 변경할 수는 없다. 
    - 프로그램 조건에 따라서 동적으로 변경하려면 ResponseEntity 를 사용하면 된다.

6. @RestController
    - @Controller 대신에 @RestController 애노테이션을 사용하면, 해당 컨트롤러에 모두 @ResponseBody 가 적용되는 효과가 있다. 
    - 따라서 뷰 템플릿을 사용하는 것이 아니라, HTTP 메시지 바디에 직접 데이터를 입력한다. 
    - 이름 그대로 Rest API(HTTP API)를 만들 때 사용하는 컨트롤러이다.
    - 참고로 @ResponseBody 는 클래스 레벨에 두면 전체 메서드에 적용되는데, 
    - @RestController 에노테이션 안에 @ResponseBody 가 적용되어 있다.

## 4. HTTP 메시지 컨버터

- 뷰 템플릿으로 HTML을 생성해서 응답하는 것이 아니라, 
- HTTP API처럼 JSON 데이터를 HTTP 메시지 바디에서 직접 읽거나 쓰는 경우 HTTP 메시지 컨버터를 사용하면 편리하다.
- HTTP 메시지 컨버터를 설명하기 전에 잠깐 과거로 돌아가서 스프링 입문 강의에서 설명했던 내용을 살펴보자.

### @ResponseBody 사용 원리
- @ResponseBody 를 사용하면
    - HTTP의 BODY에 문자 내용을 직접 반환
    - viewResolver 대신에 HttpMessageConverter 가 동작 
        - 기본 문자처리: StringHttpMessageConverter
        - 기본 객체처리: MappingJackson2HttpMessageConverter
        - byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있음

### 스프링 MVC는 다음의 경우에 HTTP 메시지 컨버터를 적용한다. 
- HTTP 요청: @RequestBody , HttpEntity(RequestEntity) 
- HTTP 응답: @ResponseBody , HttpEntity(ResponseEntity) 

### HTTP 메시지 컨버터 인터페이스
- HTTP 메시지 컨버터는 HTTP 요청, HTTP 응답 둘 다 사용된다.
- canRead() , canWrite() : 메시지 컨버터가 해당 클래스, 미디어타입을 지원하는지 체크 
- read() , write() : 메시지 컨버터를 통해서 메시지를 읽고 쓰는 기능

```
public interface HttpMessageConverter<T> {

    //(1) 메시지 컨버터가 해당 클래스, 미디어타입을 지원하는지 체크 
    boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);
    boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);

    List<MediaType> getSupportedMediaTypes();
    
    //(2) 메시지 컨버터를 통해서 메시지를 읽고 쓰는 기능
    T read(Class<? extends T> clazz, HttpInputMessage inputMessage) 
        throws IOException, HttpMessageNotReadableException;
    void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)
        throws IOException, HttpMessageNotWritableException;
}
```
### 스프링 부트 기본 메시지 컨버터
- 스프링 부트는 다양한 메시지 컨버터를 제공하는데, 대상 클래스 타입과 미디어 타입(content-type) 둘을 체크해서 사용여부를 결정한다. 
- 만약 만족하지 않으면 다음 메시지 컨버터로 우선순위가 넘어간다.
```
(일부 생략)
0 = ByteArrayHttpMessageConverter
1 = StringHttpMessageConverter
2 = MappingJackson2HttpMessageConverter
```

1. ByteArrayHttpMessageConverter 
    - byte[] 데이터를 처리한다.
    - 클래스 타입: byte[] , 미디어타입: */* ,
    - 요청 예) @RequestBody byte[] data
    - 응답 예) @ResponseBody return byte[] 쓰기 미디어타입 application/octet-stream
2. StringHttpMessageConverter 
    - String 문자로 데이터를 처리한다. 
    - 클래스 타입: String , 미디어타입: */*
    - 요청 예) @RequestBody String data
    - 응답 예) @ResponseBody return "ok" 쓰기 미디어타입 text/plain
    ```
    content-type: application/json   => 미디어타입: */* 만족

    @RequestMapping
    void hello(@RequestBody String data) {}  => 클래스 타입: String
    ```
3. MappingJackson2HttpMessageConverter 
    - application/json
    - 클래스 타입: 객체 또는 HashMap , 미디어타입 application/json 관련
    - 요청 예) @RequestBody HelloData data
    - 응답 예) @ResponseBody return helloData 쓰기 미디어타입 application/json 관련
    ```
    content-type: application/json
    @RequestMapping
    void hello(@RequestBody HelloData data) {}  => 클래스 타입: 객체 또는 HashMap
    ```


### HTTP 요청 데이터 읽기
1. HTTP 요청이 오고, 컨트롤러에서 @RequestBody , HttpEntity 파라미터를 사용한다. 
2. 메시지 컨버터가 메시지를 읽을 수 있는지 확인하기 위해 canRead() 를 호출한다.
    - 대상 클래스 타입을 지원하는가.
        - 예) @RequestBody 의 대상 클래스 ( byte[] , String , HelloData )
    - HTTP 요청의 Content-Type 미디어 타입을 지원하는가. 
        - 예) text/plain , application/json , */*
3. canRead() 조건을 만족하면 read() 를 호출해서 객체 생성하고, 반환한다.

### HTTP 응답 데이터 생성
1. 컨트롤러에서 @ResponseBody , HttpEntity 로 값이 반환된다.
2. 메시지 컨버터가 메시지를 쓸 수 있는지 확인하기 위해 canWrite() 를 호출한다.
    - 대상 클래스 타입을 지원하는가.
        - 예) return의 대상 클래스 ( byte[] , String , HelloData )
    - HTTP 요청의 Accept 미디어 타입을 지원하는가.(더 정확히는 @RequestMapping 의 produces ) 
        - 예) text/plain , application/json , */*
3. canWrite() 조건을 만족하면 write() 를 호출해서 HTTP 응답 메시지 바디에 데이터를 생성한다.


# 8. 요청 매핑 헨들러 어뎁터 구조 - RequestMappingHandlerAdapter
- 그렇다면 HTTP 메시지 컨버터는 스프링 MVC 어디쯤에서 사용되는 것일까?

- 모든 비밀은 애노테이션 기반의 컨트롤러, 그러니까 @RequestMapping 을 처리하는 핸들러 어댑터인 RequestMappingHandlerAdapter에 있다.


---
1. 클라이언트 HTTP 요청
2. DispatcherServlet
    1. 핸들러 조회(핸들러 매핑)
        - 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러) 조회
            ```
            0순위. 
            RequestMappingHandlerMapping : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
            1순위. 
            BeanNameUrlHandlerMapping    : 스프링 빈의 이름으로 핸들러를 찾는다.
            ```
    2. 핸들러 어댑터 조회
        - 핸들러를 처리할 수 있는 핸들러 어댑터 조회(핸들러 어댑터 목록)
            ```
            0순위.  
            RequestMappingHandlerAdapter   : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
            1순위. 
            HttpRequestHandlerAdapter      : HttpRequestHandler 처리
            2순위. 
            SimpleControllerHandlerAdapter : Controller 인터페이스(애노테이션X, 과거에 사용) 처리
            ```
    3. 핸들러 어댑터 실행
        - 핸들러 어댑터에 handle(handler) 요청
            1. 디스패처 서블릿이 조회한 어댑터에 handle을 실행하도록 요청하면서 핸들러 정보도 함께 넘겨준다.
            2. 어댑터는 조회된 핸들러를 내부에서 실행하고, 그 결과를 반환한다.
3. 핸들러 어댑터
    1. 핸들러 실행 요청
        - handler(컨트롤러) 호출
    2. ModelAndView 반환
        - 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환해서 반환한다.
4. DispatcherServlet
    - viewResolver호출
        - 뷰 리졸버를 찾고 실행한다.
            ```
            1순위. 
            BeanNameViewResolver : 빈 이름으로 뷰를 찾아서 반환한다. (예: 엑셀 파일 생성 기능에 사용)
            2순위. 
            InternalResourceViewResolver : JSP를 처리할 수 있는 뷰를 반환한다.
            ```
        - JSP의 경우: InternalResourceViewResolver 가 자동 등록되고, 사용된다.
5. viewResolver
    - ModelAndView로의 논리이름을 물리이름(View)으로 반환
        - 뷰 리졸버는 뷰의 논리이름을 물리이름으로 바꾸고,렌더링 역할을 담당하는 뷰 객체를 반환한다.
        - JSP의 경우 InternalResourceView(JstlView) 를 반환하는데, 내부에 forward() 로직이 있다.
6. DispatcherServlet
    - View로 render(model) 호출
    - 뷰를 통해서 뷰를 렌더링한다.
7. View
    - HTML 응답
---

- RequestMappingHandlerAdapter 동작 방식
    1. 컨트롤러의 파라미터, 애노테이션 정보를 기반으로 전달 데이터 생성
        - HttpServletRequest, Model, @RequestParam, @ModelAttribute, @RequestBody, HttpEntity
    2. ReqestMapping 핸들러어댑터
        - 2-1. ArgumentResolver
            - 핸들러 호출 시 필요한 파라미터를 넘겨줌
                1. supportsParameter() 를 호출해서 해당 파라미터를 지원하는지 체크
                2. 지원하면 resolveArgument() 를 호출해서 실제 객체를 생성
                3. 이렇게 생성된 객체가 컨트롤러 호출시 전달
                - 원한다면 직접 이 인터페이스를 확장해서 원하는 ArgumentResolver 를 만들 수도 있다.
        - 2-2. 핸들러
            - ArgumentResolver에게 받은 파라미터 전달 후, 핸들러에게서 반환값을 받음
        - 2-3. ReturnValueHandler
            - 컨트롤러의 반환값을 변환
                - ModelAndView, @ResponseBody, HttpEntity
        

## ArgumentResolver
- 정확히는 HandlerMethodArgumentResolver 인데 줄여서 ArgumentResolver 라고 부른다.
    - Argument : 매개변수
- 생각해보면, 애노테이션 기반의 컨트롤러는 매우 다양한 파라미터를 사용할 수 있었다.
    - HttpServletRequest , Model 은 물론이고, @RequestParam , @ModelAttribute 같은 애노테이션 
    - 그리고 @RequestBody , HttpEntity 같은 HTTP 메시지를 처리하는 부분까지 매우 큰 유연함을 보여주었다.
- 이렇게 파라미터를 유연하게 처리할 수 있는 이유가 바로 ArgumentResolver 덕분이다.
- 애노테이션 기반 컨트롤러를 처리하는 RequestMappingHandlerAdapter는 
    - 바로 이 ArgumentResolver 를 호출해서 컨트롤러(핸들러)가 필요로 하는 다양한 파라미터의 값(객체)을 생성한다. 
- 그리고 이렇게 파리미터의 값이 모두 준비되면 컨트롤러를 호출하면서 값을 넘겨준다.

- 스프링은 30개가 넘는 ArgumentResolver 를 기본으로 제공한다. 어떤 종류들이 있는지 살짝 코드로 확인만 해보자.
```
public interface HandlerMethodArgumentResolver {

    boolean supportsParameter(MethodParameter parameter);
    
    @Nullable
    Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
              NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;
}
```

> 참고 - 가능한 파라미터 목록은 다음 공식 메뉴얼에서 확인할 수 있다.
- https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments


## ReturnValueHandler
- HandlerMethodReturnValueHandler 를 줄여서 ReturnValueHandler 라 부른다. 
- ArgumentResolver 와 비슷한데, 이것은 응답 값을 변환하고 처리한다.
- 컨트롤러에서 String으로 뷰 이름을 반환해도, 동작하는 이유가 바로 ReturnValueHandler 덕분이다. 어떤 종류들이 있는지 살짝 코드로 확인만 해보자.
- 스프링은 10여개가 넘는 ReturnValueHandler 를 지원한다. 예) ModelAndView , @ResponseBody , HttpEntity , String

> 참고 - 가능한 응답 값 목록은 다음 공식 메뉴얼에서 확인할 수 있다.
- https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types


## HTTP 메시지 컨버터 위치
- HTTP 메시지 컨버터는 어디쯤 있을까?
- HTTP 메시지 컨버터를 사용하는 @RequestBody는 컨트롤러가 필요로 하는 파라미터의 값에 사용된다. 
    - ArgumentResolver가 해결해서 핸들러의 파라미터 값에 전달해야
- @ResponseBody 의 경우도 컨트롤러의 반환 값을 이용한다.
    - ReturnValueHandler가 해결해야

1. 요청의 경우 
- @RequestBody 를 처리하는 ArgumentResolver 가 있고, HttpEntity 를 처리하는 ArgumentResolver 가 있다. 
- 이 ArgumentResolver 들이 HTTP 메시지 컨버터(read)를 사용해서 필요한 객체를 생성하는 것이다. (어떤 종류가 있는지 코드로 살짝 확인해보자)

2. 응답의 경우 
- @ResponseBody 와 HttpEntity 를 처리하는 ReturnValueHandler 가 있다. 
- 그리고 여기에서 HTTP 메시지 컨버터(write)를 호출해서 응답 결과를 만든다.

3. 스프링 MVC는 
- @RequestBody @ResponseBody 가 있으면 
    - RequestResponseBodyMethodProcessor (ArgumentResolver)을 사용
- HttpEntity 가 있으면 
    - HttpEntityMethodProcessor (ArgumentResolver)를 사용

> 참고 - HttpMessageConverter 를 구현한 클래스를 한번 확인해보자.

## 확장
- 스프링은 다음을 모두 인터페이스로 제공한다. 따라서 필요하면 언제든지 기능을 확장할 수 있다. 
    - HandlerMethodArgumentResolver
    - HandlerMethodReturnValueHandler
    - HttpMessageConverter
- 스프링이 필요한 대부분의 기능을 제공하기 때문에 실제 기능을 확장할 일이 많지는 않다. 
- 기능 확장은 WebMvcConfigurer 를 상속 받아서 스프링 빈으로 등록하면 된다. 
- 실제 자주 사용하지는 않으니 실제 기능 확장이 필요할 때 WebMvcConfigurer 를 검색해보자