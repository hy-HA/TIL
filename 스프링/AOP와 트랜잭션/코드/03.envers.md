[참고](https://sehajyang.github.io/2020/04/15/springboot-envers-logging-for-revision/)

# envers
- envers는 hibernate 에서 만든 데이터 변경 이력을 로깅하기 위한 라이브러리
- 리포지토리에서 상속받고 컨트롤러에서 rivision을 조회하는 메서드를 만들 수 있음
- 어드민 화면에서 특정 도메인의 정보가 변경된 히스토리를 일반 사용자도 조회하고싶은 니즈가 있을 때 사용
- 과거
    - 로깅을 위해 customer_hist 와 같은 엔티티를 정의하고 customer 에 insert, update, delete 등의 작업이 발생하면,
    - history 테이블에도 같은 작업을 해줘야 했으며, 이력을 쌓아야 하는 테이블이 늘어날 수록 이러한 번거로운 반복작업을 계속해야했습니다.
- 그러나 envers를 사용하면 이러한 번거로운 작업을 대폭 줄일 수 있습니다.
    - 기본적으로 jpa로 구현되어있으며 후에 spring에도 spring data envers 프로젝트로 추가되었습니다.
    - spring data envers 역시 hibernate에서 관리하기 때문에 큰 차이는 없습니다.

# 사용법

### 의존성 추가
```
implementation 'org.springframework.data:spring-data-envers'
```

### property config 설정
- audit_table_suffix
    - auditing table의 prefix, suffix를 수정
- revision_field_name 
    - revision fk 로 쓰는 테이블들의 revid 바꾸고 싶은 경우 설정할 수 있지만 테이블마다 각각 rev_id를 따로 설정하는 것은 불가능합니다. (order_rev_id, product_rev_id 이렇게 개별로 설정 불가능)
- delete 시 aud 테이블에서 타겟 테이블의 pk 만 쌓을뿐 다른 필드의 값은 기본적으로 null 입니다.
    - null이 아니라 delete 직전의 모든 필드의 값을 쌓고 싶다면 store_data_at_delete: true 를 설정
- 더 많은 property config는 Envers Configuration Properties에서 확인
```
spring:
    jpa:
      org:
        hibernate:
          envers:
            audit_table_suffix: _log
            revision_field_name: rev_id
            store_data_at_delete: true
```

### @Audited로 변경이력 저장할 테이블 설정
1. @Audited(targetAuditMode = NOT_AUDITED)
2. @AuditOverride(forClass = BaseEntity.class)
    -  extends 한 엔티티의 이력도 추가되길 원한다면 @AuditOverride(forClass=BaseEntity.class) 도 추가
3. 추적하지 않을 필드
    - @NotAudited 추가
4. 그러면 기본적으로 총 두개의 테이블이 생성됨
    - customer 엔티티의 상단에 @Audited를 추가하면 revinfo, customer_aud 테이블이 생성됨
        1. revinfo
            - central revision table 로, 최초 1회만 생성되며, 이 revinfo 테이블을 삭제하거나 disable 할 순 없습니다. 
            - 네이밍 및 필드 변경은 가능
            - rev 필드의 네이밍 변경을 각 테이블마다 다르게 줄 수 없습니다.
        2. entity_aud 테이블
            - rev_type필드는 int타입으로 생성, 수정, 삭제를 구분하는 컬럼
            - 타입, 필드명, 값을 변경할 순 없음
            - 0 : insert
            - 1 : update
            - 2 : delete
5. rev 컬럼의 타입
- central revision table인 revinfo의 pk인 rev 컬럼의 타입은 기본적으로 int 로 되어있음
- 데이터가 20억개 이상 넘어가면 오류가 발생하므로, 권남님 포스팅의 [REV 를 long 으로 변경해야한다]처럼 int 타입을 long 타입으로 변경해줘야
```
@Entity
@Audited(targetAuditMode = NOT_AUDITED)
public class Student extends BaseEntity {
    ...

    @NotAudited
    @Column(unique = true)
    private String residentNumber;

}
```
### 그 외
1. 테이블이 서로 연관관계인 경우 추적 테이블을 만들지 않을 경우
    - 연관관계 추적 테이블 생성은 되지만 추적하진 않을거라면 
    - 연관관계 테이블 생성도 하지 않고 추적하지도 않을거라면 
2. 양방향관계에선 AuditMappedBy로 관계 명시를 해줘야
3. 상속관계에 있는 테이블도 audit 하고싶은 경우
4. queryDSL과 함께 쓰면 조회시 호환이 되지 않는 문제가 발생



<br>
<br>
