# 회원 도메인 

1. 회원 도메인 설계
2. 회원 도메인 개발
    1. Grade Enum 생성
    2. Member 클래스 생성
        1. 변수(id,name,grade) 선언
        2. 생성자 생성
        3. 게터세터
3. MemberRepository 인터페이스 생성
    1. save(회원저장)기능과 findeNyId(회원조회) 기능 생성
4. MemoryMemberRepository 구현체 생성
    1. 컬렉션 맵으로 생성(?)
    2. override된 기능에 구현 코딩
5. 회원 서비스 인터페이스 생성
    1. 회원가입, 회원조회 기능 생성
        - void join(Member member)
        - Member findMember(Long memberId)
6. 회원 서비으 구현체 클래스 생성
    1. 리포지토리 인터페이스와 구현체 주입(?)
        - private final MemberRepository memberRepository = new MemoryMemberRepository();
        >  의존관계가 인터페이스뿐만 아니라 구현까지 모두 의존하고 있음. OCP의 원칙을 준수하지 못하고 DIP를 잘 지키지 못하고 있음. 
    2. override된 기능에 구현 코딩

# 테스트
1. MemberApp 클래스 생성

# 주문과 할인 도메인

1. 할인정책 인터페이스 생성
    1. 할인 대상 금액 리턴해주는 기능 생성
        - int discount(Member, int price)   
            - Member클래스 임포트
2. 정액할인정책 구현체 생성
    1. override된 기능에 구현 코딩
        - vip면 천원 할인
3. 주문 도메인 생성
    1. 변수( 회원아이디, 상품이름, 상품 가격, 할인가격) 생성
        - 주문했을 때 만들어지는 객체
    2. 생성자 생성
    3. 게터세터
    4. 계산 로직 생성
        - public int calculatePrice() {
            return itemPrice - discountPrice;
        }
    5. toString 생성 
4. 주문서비스 인터페이스
    1. 주문생성 기능
        - Order createOrder(Long memberId, String itemName, int itemPrice);
            - 파라미터는 반환할 값을 위함
5. 주문서비스 구현체 클래스 생성
    1. 리포지토리 할인정책 주입
    2. override한 기능 구현 코딩
# 테스트
1. OrderApp 클래스 생성
- 단위테스트가 중요 : 시간이 절약됨

# 새로운 할인 정책 
1. 정률할인정책 구현체 생성
2. 단위테스트
3. 정액할인정책을 정률할인정책으로 변경
    1. 주문서비스 구현체 클래스에서 '리포지토리 할인정책 주입' 부분 변경
> 주문서비스 클라이언트(orderServiceImpl)은 주문정책 인터페이스(DiscountPolicy)에 의존하면서 구체 클래스(FixDiscountPolicy)에도 의존하고 있음. (DIP위반) 따라서 정액에서 정률로 변경하면 클라이언트 코드에 영향을 주므로 OCP를 위반하게 됨.

# DIP와 OCP에 맞도록 변경
1. 인터페이스에만 의존하도록 변경
    - orderServiceImpl의 리포지토리 할인정책 주입 코드 변경
        - private final DiscountPolicy discountPolicy = new RateDiscountPolicy(); 를 아래처럼 변경
        - private final DiscountPolicy discountPolicy;
            ```
            final이 있으면 생성자를 통해서 할당이 되어야함(?)
            ```
        - 이제 구현체를 생성해야 함. 
        - 일단 생성자 생성해둠
            ```
            public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
                this.memberRepository = memberRepository;
                this.discountPolicy = ciscountPolicy;
            }
            ```
            ```
            public MemberServiceImple(MemberRepository memberRepository) {
                this.memberRepository = memberRepository;
            }
            ```
2. 누군가 대신 인터페이스의 구현체가 생성되도록 설정 (DI) 
    - (SRP. 한 클래스는 하나의 책임만)
    - (DIP. 추상화에 의존해야지 구체화에 의존하면 안됨)
    - (OCP. 소프트웨어 요소는 확장에는 열려있으나 변경할 필요가 없어야)
    1. 구현객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스를 만들자(AppConfig)
        - AppConfig 생성한 객체 인스턴스(MembeServiceImpl,OrderServiceImpl)의 참조를 생성자를 통해 주입함
        1. 멤버서비스 객체 생성하고 리턴값으로 구현체 설정
            ```
            public MemberService memberService() {
                return new MembeServiceImpl(new MemoryMemberRepository);
            }
            ```
            ```
            public OrderService orderService() {
                return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
            }
            ```
3. AppConfig 실행하기
    1. 멤버서비스 객체 생성시 AppConfig 객체에서 불러오기
        ```
        MemberServive memberServive = new MemberServiveInpl();을 아래처럼 변경
        MemberServive memberServive = appConfig.memberServive();
        // appConfig는 멤버서비스impl을 생성하면서 Memory멤버리포지토리를 사용할거라는 것을 주입함
        ```
    2. AppConfig 리팩토링 (SRP)
        - 구성 정보에서 역할과 구현을 명확하게 분리
        - 역할이 잘 드러남
        - 중복 제거
# 새로운 구조와 할인 정책 적용
- 이제  appConfig만 수정하면 됨

# IoC컨테이너,DI컨테이너
- AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 IoC컨테이너,DI컨테이너
- JUnit도 IoC
- IoC (제어의 역전)

# 스프링으로 변환
## @Configuration | @Bean
## ApplicationContext
- 기존에는 개발자가 appConfig를 사용해서 직접 객체 생성했지만 이제는 스프링 컨테이너를 통해 사용
- 스프링 컨테이너라 함
- 인터페이스
- 스프링 컨테이너는 xml를 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있다
## AnnotationConfigApplicationContext
- ApplicationContext 인터페이스의 구현체
- 빈을 컨테이너에 등록해서 관리해줌

# 스프링 컨테이너와 스프링 빈
1. 스프링 컨테이너를 생성하고 설정정보를 참고해서 스프링 빈을 등록, 의존관계를 설정함.
    - 스프링은 빈을 생성하고 의존관계를 주입하는 단계가 나누어져 있음
    - 그런데 생성자를 호출하면서 의존관계 주입도 한번에 처리됨
2. 스프링 컨테이너에서 데이터를 조회
    - ac.getBeanDefinitionNames() : 스프링에 등록된 모든 빈 이름 조회
    - ac.getBean() : 빈 이름으로 빈 객체(인스턴스)를 조회

# 스프링 빈 조회 
1. 기본
- 스프링 컨테이너에서 스프링 빈을 찾는 가장 기본적인 조회 방법
    1. ac.getBean(빈이름, 타입)
    2. ac.getBean(타입)
2. 동일한 타입이 둘 이상
    - 이름을 붙여준다

3. 상속관계 (중요)
- 부모 타입으로 조회하면 자식타입도 함께 조회한다
- 그래서 모든 자바 객체의 최고 부모인 Object 타입으로 조회하면 모든 스프링 빈을 조회한다.

# BeanFactory와 ApplicationContext
- BeanFactory나 ApplicationContext를 스프링 컨테이너라 한다. 

## 1. BeanFactory 
- 스프링 컨테이너의 최상위 인터페이스다.
- 스프링 빈을 관리하고 조회하는 역할을 담당한다. 
- getBean() 을 제공한다.
- 지금까지 우리가 사용했던 대부분의 기능은 BeanFactory가 제공하는 기능이다. 

## 2. ApplicationContext 
- BeanFactory 기능을 모두 상속받아서 제공한다.
- 빈을 관리하고 검색하는 기능을 BeanFactory가 제공해주는데, 그러면 둘의 차이가 뭘까? 
- 애플리케이션을 개발할 때는 빈은 관리하고 조회하는 기능은 물론이고, 수 많은 부가기능이 필요하다. 
    1. 메시지소스를 활용한 국제화 기능 
    - 예를 들어서 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력 
    2. 환경변수 
    - 로컬, 개발, 운영등을 구분해서 처리 
    3. 애플리케이션 이벤트 
    - 이벤트를 발행하고 구독하는 모델을 편리하게 지원 
    4. 편리한 리소스 조회 
    - 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회 

# 스프링 빈 설정 메타 정보 - BeanDefinition
- BeanDefinitio을 빈 설정 메타정보라 한다
    - @Bean, <bean> 당 각각 하나씩 메타 정보가 생성됨
- 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다