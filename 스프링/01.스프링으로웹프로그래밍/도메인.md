
# 회원 엔티티

## 회원 클래스
@Entity
@Getter @Setter
```
@Entity
@Getter @Setter
public class Member {}
```
## 회원 아이디
@Id @GeneratedValue
@Column(name = "member_id")
```
@Id @GeneratedValue
@Column(name = "member_id")
private Long id;
```
## 회원 주소
@Embedded
```
@Embedded
private Address address;
```
## 회원이 주문한 주문들
@JsonIgnore
@OneToMany(mappedBy = "member")
```
@JsonIgnore
@OneToMany(mappedBy = "member")
private List<Order> orders = new ArrayList<>();
```

# 주문 엔티티
> 엔티티와 메소드

> 1.엔티티
## 주문 클래스
@Entity
@Table(name = "orders")
@Getter @Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
```
@Entity
@Table(name = "orders")
@Getter @Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Order {}
```
## 주문 아이디
@Id @GeneratedValue
@Column(name = "order_id")
```
@Id @GeneratedValue
@Column(name = "order_id")
private Long id;
```

## 주문한 회원
@ManyToOne(fetch = LAZY)
@JoinColumn(name = "member_id")
```
@ManyToOne(fetch = LAZY)
@JoinColumn(name = "member_id")
private Member member;
```

## 주문 상품들
@JsonIgnore
@OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
```
@JsonIgnore
@OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
private List<OrderItem> orderItems = new ArrayList<>();
```

## 배송
```
@JsonIgnore
@OneToOne(fetch = LAZY, cascade = CascadeType.ALL)
@JoinColumn(name = "delivery_id")
private Delivery delivery;
```

## 주문상태
```
@Enumerated(EnumType.STRING)
private OrderStatus status; //주문상태 [ORDER, CANCEL]
```
> 2.메서드
```
public void setMember(Member member) {
    this.member = member;
    member.getOrders().add(this);
}

public void addOrderItem(OrderItem orderItem) {
    orderItems.add(orderItem);
    orderItem.setOrder(this);
}

public void setDelivery(Delivery delivery) {
    this.delivery = delivery;
    delivery.setOrder(this);
}
```

# 주소 엔티티
> 엔티티와 메소드

> 1.엔티티
## 주소 클래스
```
@Embeddable
@Getter
public class Address { }
```

## 도시, 거리, zipcode
```
private String city;
private String street;
private String zipcode;
```
> 메서드
```
protected Address() {
}
```
```
public Address(String city, String street, String zipcode) {
    this.city = city;
    this.street = street;
    this.zipcode = zipcode;
}
```

# 다대다 - orderItem
```
@Entity
@Getter @Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class OrderItem { }
```
```
@Id @GeneratedValue
@Column(name = "order_item_id")
private Long id;

@ManyToOne(fetch = LAZY)
@JoinColumn(name = "item_id")
private Item item;

@JsonIgnore
@ManyToOne(fetch = LAZY)
@JoinColumn(name = "order_id")
private Order order;

private int orderPrice; //주문 가격
private int count; //주문 수량
```

# 상품 엔티티 (응집도를 위해 비즈니스로직 추가)
```
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "dtype")
@Getter @Setter
public abstract class Item { }
```
```
@Id
@GeneratedValue
@Column(name = "item_id")
private Long id;

private String name;
private int price;
private int stockQuantity;

@ManyToMany(mappedBy = "items")
private List<Category> categories = new ArrayList<>();
}
```
## 비즈니스 로직 추가(객체지향적)
- 엔티티 자체가 해결할 수 있다면 엔티티 안에 비즈니스 로직을 넣는게 좋음
- 재고수량이 엔티티 안에 있기 때문에 응집도가 높음

```
//==비즈니스 로직==//
// (1) stock 증가
public void addStock(int quantity) {
    this.stockQuantity += quantity;
}

// (2) stock 감소
public void removeStock(int quantity) {
    int restStock = this.stockQuantity - quantity;
    if (restStock < 0) {
        throw new NotEnoughStockException("need more stock");
    }
    this.stockQuantity = restStock;
}
```
- NotEnoughStockException 클래스 생성
```
package jpabook.jpashop.exception;

public class NotEnoughStockException extends RuntimeException {

    public NotEnoughStockException() {
        super();
    }

    public NotEnoughStockException(String message) {
        super(message);
    }

    public NotEnoughStockException(String message, Throwable cause) {
        super(message, cause);
    }

    public NotEnoughStockException(Throwable cause) {
        super(cause);
    }

}
```

# 책 엔티티
```
@Entity
@DiscriminatorValue("B")
@Getter
@Setter
public class Book extends Item { }
```
```
private String author;
private String isbn;
```