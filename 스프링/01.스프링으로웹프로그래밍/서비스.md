# 서비스
# 회원 서비스
## 스프링빈 등록
- 스프링빈 등록
    ```
    @Service
    public Long join(Member member) {
    ```
## 트랜잭션
1. JPA의 모든 데이터 변경, 로직들은 가급적이면 트랜잭션 안에서 실행되어야
2. @Transactional 사용
3. 클레스 레벨에 해당 어노테이션을 쓰면 public 메서드는 기본적으로 같이 적용됨
4. 옵션
    - (readOnly = true)
        - 조회하는 곳에서 JPA의 성능이 최적화됨
5. 클래스 설정 시 기본옵션을 readOnly로 쓰기를 사용하는 메서드에 @Transactional을 사용하면 최적화할 수 있음
    ```
    @Service
    @Transactional(readOnly = true)
    public Long join(Member member) {

        @Transactional
        public Long join(Member member) { }
    ```


## 회원 리포지토리 주입
- 리포지토리 주입방법 1 - 필드 주입
    - 단점 : 수정 불가
    ```
    @Autowired
    private final MemberRepository memberRepository;
    ```
- 리포지토리 주입방법 2 - 세터 주입
    - 장점 : 테스트코드 작성 시 mock 등을 주입해줄 수 있음
    - 단점 : 런타임, 실제 어플리케이션이 돌아가는 시점에 누군가 변경할 수 있음
        - 그래서, 잘 생각하면 어플리케이션 로딩 시점에 조립이 끝나버림. 조립 이후, 어플리케이션 동작 중에 리포지토리를 바꿀일이 별로 없음
        - 그래서 세터 주입이 좋지 않음
    ```
    private final MemberRepository memberRepository;

    @Autowired
    public void setMemberRepository(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
    ```
- 리포지토리 주입방법 3 - 생성자 주입
    - 스프링에서 MemberService가 뜰 때 생성자에서 리포지토리를 주입해줌
        - 장점 
            - 중간에 set으로 바꿀 수 없음
            - 테스트케이스 작성 시 MemberService의 객체를 new로 생성 시 리포지토리를 주입해야 한다는 것을 표시해서(붉은 밑줄) 리포지토리를 의존하고 있다는 것을 명확하게 알 수 있음
            - 최신버전 스프링에서는 생성자가 1개만 있는 경우 스프링이 @Autowired없어도 자동으로 주입해서 편함
- final
    - 변경할 일이 없으므로 final로 선언
    - final로 설정하면 컴파일 시점에 오류를 체크해줄 수 있음
        - 예. 생성자는 만들었는데 값을 세팅을 안했다던지

    ```
    private final MemberRepository memberRepository;

    @Autowired
    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
    ```
## 롬복 
1. @AllArgsConstructor
- 필드를 가지고 생성자를 만들어줌
- 1번케이스를 2번으로 줄일 수 있음
    - 1번
    ```
    private final MemberRepository memberRepository;

    @Autowired
    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
    ```
    - 2번
    ```
    private final MemberRepository memberRepository;
    ```

2. @RequiredArgsConstructor
- final이 있는 필드만 가지고 생성자를 생성해줌
- @AllArgsConstructor보다 더 나은 방법



## 기능 - 회원 가입
1. 중복회원 검증
    - 중복회원이면 예외를 터트릴 것
    ```
    @Transactional
    public Long join(Member member) { 
        validateDuplicateMember(member); 


        private void validateDuplicateMember(Member member) {
            List<Member> findMembers = memberRepository.findByName(member.getName());
            if (!findMembers.isEmpty()) {
                throw new IllegalStateException("이미 존재하는 회원입니다.");
            }
        }
    }
    ```
2. 회원 저장
    ```
    memberRepository.save(member);
    ```

3. 아이디 반횐
- em.persist
    - 영속성 컨텍스트에 값을 넣을 때 키가 pk의 값을 넣음(?)
    ```
    return member.getId();
    ```


## 기능 - 회원 전체 조회

```
public List<Member> findMembers() {
    return memberRepository.findAll();
}
```

## 기능 - 회원 단건 조회

```
public Member findOne(Long memberId) {
    return memberRepository.findOne(memberId);
}
```