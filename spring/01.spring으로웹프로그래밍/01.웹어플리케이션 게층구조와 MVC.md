# 웹 어플리케이션 계층구조와 MVC


# 1. 웹 어플리케이션 계층 구조

## 1. 계층 구성요소

### 도메인(엔티티?) 
- 비즈니스 도메인 객체
    - 예) 회원, 주문, 쿠폰 등 주로 데이터베이스에 저장하고 관리됨. 

    ```
    domain/Member.java>>

    pubic class Member {
        private Long id;
        private String name;

        //게터,세터
        ~~~
    }
    ```

### 리포지토리 
- 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리
- 인터페이스 클래스 + 구현체 클래스

- 인터페이스(repository/MemberRepository.java)
    - 회원 객체를 저장하는 저장소
    - 추상 메서드 작성
    ```
    public interface MemberRepository {
        Member save(Member member);
        Optional<Member> findBuId(Long id);
        Optional<Member> findByName(String name);
        List<Member> findAll();
    }
    ```

- 구현체 (repository/MemoryMemberRepository.java)
    - 인터페이스에서 implements 후 구현
    ```
    public class MemoryMemberRepository implements MemberRepository {

        // 메모라 저장할 컬렉션 설정
        private static Map<Long, Member> store = new HashMap<>();
    private static long sequence = 0L;

        @Override
        // 인터페이스 기능들 하나하나 구현
    }
    ```
- 조립
    ```
    @Bean
    public MemberRepository memberRepository() {
        return new 리포지토리구현클래스(dataSource);
    }
    ``` 

참고] [컬렉션 프레임워크](#1-컬렉션-프레임워크)

참고] [옵셔널](#3-옵셔널)

### 컨트롤러 
- 웹스프링이 뜰 때 스프링 컨테이너라는 통이 생김. 
- Cotroller라는 어노테이션이 있으면 해당 컨트롤러 객체를 생성해서 스프링에 넣어고 관리함. 
- 이때 @Autowired로 관리되는 생성자들을 연결시켜줌
    - 이때 생성자는 스프링 빈으로 등록되어있어야
- 스프링 빈을 등록하는 방법
   1) 컴포넌트 스캔과 자동 의존관계 설정.
      - 컴포넌트 스캔원리
          - @Component가 있으면 스프링 빈으로 자동 등록. 
          - @Controller/@Service/@Repositort도 스프링 빈으로 자동 등록됨. 
    2) 자바 코드로 직접 스프링 빈 등록.
    
    ```
    @Controller
    public class MemberController {

        private final MemberService memberService;
        public MemberController(MemberService memberService) {
            this.memberService = memberService;
        }
    }
    ```
    - MemberService 객체는 new로 생성하는것이 아닌 DI로 외부로부터 주입받음
    - DI로 주입받기 위해 @Service 어노테이션 사용
### 서비스 
- 모델의 일부 - 핵심 비즈니스 로직 구현
- 비즈니스 도메인 객체를 통해 핵심 비즈니스 로직이 동작하도록 구현한 객체.
- ex) 회원은 중복가입이 안된다 등

    ```
    service/Memberservice.java>>


    public class MemberService {

    // (1) 회원 리포지토리 객체 생성
    private final MemberRepository memberRepository = new MemoryMemberRepository();

    // (2) 회원가입 서비스
    public Long join(Member member) {

        validateDuplicateMember(member); // (3) 중복 회원 검증
        memberRepository.save(member);
        return member.getId();
    }

    private void validateDuplicateMember(Member member) {
        memberRepository.findByName(member.getName())
            .ifPresent(m -> {
                throw new IllegalStateException("이미 존재하는 회원입니다.");
            });
    }
    ```


## 2. '도메인 주도 설계'의 레이어와 컴포넌트 목록
(참고: 스프링 프레임워크 첫걸음)

### 1. 애플리케이션 레이어
- 클라이언트와의 데이터 입출력을 제어하는 레이어
    - Controller : 제어 역할 담당
    - View : 화면표시
    - Form : 화면의 폼에 대응

### 2. 도메인 레이어
- 애플리케이션의 중심이 되는 레이어. 업무 처리를 수행하는 레이어
    - Service : 인터페이스로 생성
        - 트랜잭션 경계는 Service에서 설정 
    - ServiceImpl : Service를 구현. 
        - 클래스에 @Service 어노테이션 부여해서 인스턴스 생성 대상으로 지정.
        - @Override된 메서드에 구체적 메서드 작성
    - 도메인 객체 : 엔티티와 같은 역할
    - Repository : 인터페이스로 생성

### 3. 인프라스트럭처 레이어
- 데이터베이스에 대한 데이터 영속성(persistence context) 등을 담당하는 레이어
    - RepositoryImpl : O/R Mapper 자동생성
    - O/R Mapper : 스프링데이터 JDBC 사용


<br> 
<br> 

# 2. MVC 모델

##  모델
- 비즈니스 로직을 담당. 서비스 처리.
    - Service는 모델의 일부로 비즈니스 로직 처리의 시작로 생각할 수 있음. (트랜잭션의 시작)
- ex.
    ```
    아이디 중복 확인의 비즈니스 로직)
    - 사용자가 입력한 아이디값을 메모리에 저장
    - 회원 데이터베이스에 같은 아이디가 있는지 확인
    - 중복 여부를 화면에 표시할 수 있게 전달
    ```
    ### 1-1. 모델 인터페이스
    - 처리한 데이터를 뷰에 표시하고 싶을 경우 데이터를 전달하는 역할
    - 스프링 MVC에 의해 관리되며, 수동 또는 자동으로 객체를 저장하고 관리하는 기능을 제공
    - Model을 이용하고 싶은 경우 요청 핸들러 메서드의 인수에 Model 타입을 전달. 그러면 스프링 MVC가 자동으로 Model 타입 인스턴스를 설정

    ### 1-2. 기억해야할 중요한 메서드
    - addAttribute
        - 특정 이름에 대해 값을 설정. 저장하고 싶은 값에 별명을 붙인다고 생각하면 됨. 뷰에서는 별명에 사용한 이름을 이용
        ```
        Model addAttribute(String name, Object value)
        ```


## 뷰
- 입력/출력 등을 표시하는 역할

## 컨트롤러
- 모델과 뷰를 제어하는 역할

<br>

# 3. 스프링 MVC

## 1. 스프링 MVC
- 웹 애플리케이션을 간단하게 만들 수 있는 기능을 제공하는 프레임워크

1. 프런트 컨트롤러 패턴
    - 설계 패턴의 하나인 디자인 패턴
    - 모든 요청을 컨트롤러가 받아, 그 후 담당하는 컨트롤러에 적절하게 할당하는 설계
2. 스프링 MVC 주요기능
    - 화면전환
    - 사용자가 사용하는 브라우저와 서버간의 입출력 데이터 전달을 단순화
3. 스프링 MVC의 구성요소
    - DispatcherServlet
        - 모든 요청을 수신하는 프런트 컨트롤러
    - 컨트롤러
        - 요청에 대응해서 처리할 내용이 있는 곳
    - 서비스(비즈니스 로직) 처리
        - 데이터베이스에 접속해서 데이터를 취득하거나 데이터를 가공하는 등 여러가지 작업을 실행
        - 개발자가 설게하고 구현(스프링MVC와 관계없음)
    - Model
        - 컨트롤러에서 넘겨주는 표시용 데이터 등을 저장하는 객체
        - HttpServletRequest, HttpSession과 같은 기능 제공
    - 뷰
        - 화면 표시 처리(구체적으로는 JSP 등의 처리)


## 2. 요청을 받고 응답을 보낼 때까지의 흐름
1. url 요청
    - DispatcherServlet이 클라이언트에게서 요청을 받음(프런트 컨트롤러 패턴)
2. 컨트롤러 메서드 
    - DispatcherServlet이 컨트롤러의 요청 핸들러 메서드를 호출
3. 비즈니스 로직 처리 & 결과 취득
    - 컨트롤러는 비즈니스 로직 처리를 실행해서 처리 결과를 취득
4. 컨트롤러 (결과를 모델에 저장 & 뷰이름 반환)
    - 처리 결과를 Model로 설정하고 컨트롤러는 뷰 이름을 반환
5. 뷰 화면 전달
    - DispatcherServlet은 뷰 이름을 대응하는 뷰에 대해서 화면 표시 처리 요청


>  어노테이션 - @GetMaping





# 추가개념

## 1. 컬렉션 프레임워크
- 복수의 데이터를 더 쉽게 사용할 수 있게 컬렉션(Collection) 클래스를 제공
1. 컬렉션의 종류
    1. 리스트
        - 순서대로 데이터를 저장. 중복을 허용
    2. 세트
        - 순서를 유지하는 집합. 중복을 허용하지 않음
    3. 맵
        - 키와 값의 쌈으로 이루어진 데이터 집합. 순서는 유지되지 않고 키의 중복을 허용하지 않으며 값의 중복을 허용
2. 제네릭
- 컬렉션에 넣을 수 있는 형태를 제한하는 것
    - ```<String>```

3. 예제 - List
- List 인터페이스의 구현 클래스
    1. ArrayList
        - List 인터페이스의 구현 클래스에서 가장 많이 사용. 요소를 배열로 유지하기 때문에 요소의 검색을 고속으로 처리 가능. 요소의 수가 많아지면 추가/삭제를 하는데 시간이 걸림.
    2. LinkedList
        - 요소끼리 전후 양방향의 링크로 참조하는 리스트 구조를 이용해 관리. 요소의 추가나 삭제가 ArrayList보다 빠름. 그러나 특정 요소 검색과 같은 인덱스 값에 의한 무작위 엑세스에는 적합하지 않음
```
// string 타입을 저장할 List 준비
List<String> tomato = new ArrayList<>();
//string 타입의 데이터 넣기
tomato.add("홍길동")
//for 문으로 데이터를 하나씩 출력
for (String name : tomato) {
    System.out.println(name);
}
```
 
4. 예제 - Map
```
private static Map<Long, Member> tomato = new HashMap<>();
```
## 2. 시퀀스
- 키값을 생성

## 3. 옵셔널
- 자바8 기능
- 옵셔널에서 값을 꺼낼 때
    - get()사용
    ```
    리포지토리>>
    //findById 메서드의 반환값은 옵셔널
    public Optional<Member> findById(Long id) {
            return Optional.ofNullable(store.get(id));
    }
    
    테스트>>
    repository.findById(member.getId()).get();
    ```

