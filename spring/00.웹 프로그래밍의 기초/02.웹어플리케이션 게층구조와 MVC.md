# 1. 웹 어플리케이션 계층 구조

## 컨트롤러, 서비스, 리포지토리, 도메인

### 1 컨트롤러 
    웹 MVC의 컨트롤러 역할

### 2 서비스 
    핵심 비즈니스 로직 구현
    비즈니스 도메인 객체를 통해 핵심 비즈니스 로직이 동작하도록 구현한 객체.
    ex) 회원은 중복가입이 안된다 등

#### 도메인 
    비즈니스 도메인 객체
    예) 회원, 주문, 쿠폰 등 주로 데이터베이스에 저장하고 관리됨. 

### 3 리포지토리 
    데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리
    인터페이스 클래스 + 구현체 클래스



## '도메인 주도 설계'의 레이어와 컴포넌트 목록
1. 애플리케이션 레이어
    - 클라이언트와의 데이터 입출력을 제어하는 레이어
        - Controller : 제어 역할 담당
        - View : 화면표시
        - Form : 화면의 폼에 대응
2. 도메인 레이어
    - 애플리케이션의 중심이 되는 레이어. 업무 처리를 수행하는 레이어
        - Service : 인터페이스로 생성
            - 트랜잭션 경계는 Service에서 설정 
        - ServiceImpl : Service를 구현. 
            - 클래스에 @Service 어노테이션 부여해서 인스턴스 생성 대상으로 지정.
            - @Override된 메서드에 구체적 메서드 작성
        - 도메인 객체 : 엔티티와 같은 역할
        - Repository : 인터페이스로 생성
3. 인프라스트럭처 레이어
    - 데이터베이스에 대한 데이터 영속성(persistence context) 등을 담당하는 레이어
        - RepositoryImpl : O/R Mapper 자동생성
        - O/R Mapper : 스프링데이터 JDBC 사용


# 2. MVC 모델

## 요청을 받고 응답을 보낼 때까지의 흐름
1. DispatcherServlet이 클라이언트에게서 요청을 받음(프런트 컨트롤러 패턴)
2. DispatcherServlet이 컨트롤러 요청 핸들러 메서드를 호출
3. 컨트롤러는 비즈니스 로직 처리를 실행해서 처리 결과를 취득
4. 처리 결과를 Model로 설정하고 뷰 이름을 반환
5. DispatcherServlet은 뷰 이름을 대응하는 뷰에 대해서 화면 표시 처리 요청
6. 클라이언트가 응답을 받고 브라우저 화면에 표시

## 1. 모델
- 비즈니스 로직을 담당. 서비스 처리.
    - Service는 모델의 일부로 비즈니스 로직 처리의 시작로 생각할 수 있음. (트랜잭션의 시작)
- ex.
    ```
    아이디 중복 확인의 비즈니스 로직)
    - 사용자가 입력한 아이디값을 메모리에 저장
    - 회원 데이터베이스에 같은 아이디가 있는지 확인
    - 중복 여부를 화면에 표시할 수 있게 전달
    ```
    ### 1-1. 모델 인터페이스
    - 처리한 데이터를 뷰에 표시하고 싶을 경우 데이터를 전달하는 역할
    - 스프링 MVC에 의해 관리되며, 수동 또는 자동으로 객체를 저장하고 관리하는 기능을 제공
    - Model을 이용하고 싶은 경우 요청 핸들러 메서드의 인수에 Model 타입을 전달. 그러면 스프링 MVC가 자동으로 Model 타입 인스턴스를 설정

    ### 1-2. 기억해야할 중요한 메서드
    - addAttribute
        - 특정 이름에 대해 값을 설정. 저장하고 싶은 값에 별명을 붙인다고 생각하면 됨. 뷰에서는 별명에 사용한 이름을 이용
        ```
        Model addAttribute(String name, Object value)
        ```


## 2. 뷰
- 입력/출력 등을 표시하는 역할

## 3. 컨트롤러
- 모델과 뷰를 제어하는 역할


## 어노테이션
@GetMaping





- 회원 서비스 
    - 회원 비즈니스 로직에 있는 회원 서비스

- 회원 리포지토리 (인터페이스)
    - 회원 저장은 인터페이스로 설계할 것. 

    - 아직 데이터 저장소가 선정되지 않아서, 우선 인터페이스로 구현 클래스를 변경할 수 있도록 설계

    - 추후 데이터 저장소 선정 후 바꿔끼우기 위해 인터페이스로 설계. 

    
- 메모리 회원리포지토리 
    - 메모리로 단순하게 저장하는 구현체
    - 데이터 저장소는 이후 RDB, NoSQL 등 다양한 저장소를 고민중인 상황으로 가정
    - 개발을 진행하기 위해서 초기 개발 단계에서는 구현체로 가벼운 메모리 기반의 데이터 저장소 사용. 

# 도메인
- domain팩토리/Member클래스
```
pubic class Member {
    private Long id;
    private String name;

    //게터,세터
}
```
# 리포지토리
- repository패키지/MemberRepository인터페이스
    - 회원 객체를 저장하는 저장소를 만들 것
    - 인터페이스 기능 작성
        - ex) 
            ```
            public interface MemberRepository {
                Member save(Member member);
                Optional<Member> findBuId(Long id);
                Optional<Member> findByName(String name);
                List<Member> findAll();
            }
            ```

- repository패키지/MemoryMemberRepository클래스
    - 구현체
    - 인터페이스에서 implements 후 구현
    ```
    public class MemoryMemberRepository implements MemberRepository {

        private static Map<Long, Member> store = new HashMap<>();
        private static long sequence = 0L;

        @Override
        // 인터페이스 기능들 하나하나 구현
    }
    ```
- 조립
    ```
    @Bean
    public MemberRepository memberRepository() {
        return new 리포지토리구현클래스(dataSource);
    }
    ``` 
# 테스트

- 클래스에서 cmd + shift + t를 누르면 자동으로 클래스 생성됨.
- 클래스 라이브러리는 JUnit5로 선택
- Member선택 후 ok

# 서비스
- 회원 리포지토리와 회원 도메인을 활용해서 비즈니스 로직을 작성.

- service패키지/Memberservice클래스
    ```
    MemberService.java>>

    public class MemberService {

    // 회원 리포지토리 객체 생성
    private final MemberRepository memberRepository = new MemoryMemberRepository();

    //회원가입 서비스
    public Long join(Member member) {

    validateDuplicateMember(member); //중복 회원 검증
    memberRepository.save(member);
    return member.getId();
    }

    private void validateDuplicateMember(Member member) {~~~}
    ```

# 컨트롤러

