
## 오버로딩(Overloading)

- 오버로딩
    - 이름은 같지만 매개변수가 다른 여러 메소드를 가질 수 있도록 하는 기능
    - 메서드가 오버로드되면 Java는 전달된 인수의 수와 유형에 따라 실행할 메서드를 결정한다
    - 입력에 따라 다른 작업을 수행할 수 있는 보다 유연하고 재사용 가능한 코드를 만들 수 있게 하는 기능

> 오버로딩 : 동일한 이름을 가진 여러 메서드를 클래스에 정의할 수 있는 기능
> 오버라이딩 : 부코 클래스의 함수를 재정의 하는 기능

---

## 늦은 바인딩 / 이른 바인딩

- 늦은 바인딩
    - 동적 바인딩이라고도 한다.
    - 호출되는 메서드 구현이 프로그램 실행 중에 결정된다
    - 다형성은 늦은 바인딩이다.
- 이른 바인딩
    - 정적 바인딩이라도 한다
    - C에서 배웠던 함수의 호출 방식이다
    - 어떤 함수 구현을 호출해야 할지가 빌드 중에 결정된다.
      - 따라서 함수 호출문을 바로 jmp 명령어로 교체 가능하다
      - jmp하는 주소는 그 함수의 어셈블리어 코드가 시장되는 메모리 주소
    - C에서 이게 가능한 이유는 다형성을 지원하지 않기 때문이다.

> 사실 C에 없는 기능은 하드웨어에 없다. 그렇기 때문에 사실 C에도 늦은 바인딩이 있다. 바로 **함수 포인터**다. 함수 포인터를 직접 전달하는 방식으로 늦은 바인딩을 구현할 수 있다.
>
> Java는 이 함수포인터 같은 기능을 편하게 사용할 수 있도록 해준것이다. Java에만 있는 기능은 C의 기능들을 조합해서 만든 것이기 때문에 C에서 이 기능이 아주 없다고 단정짓지 않아야 한다. (마찬가지로 Java도 final을 사용하여 이른바인딩이 가능하다.)
>
> ![](https://i.imgur.com/d9N3K7V.png)

---

## Object의 다형적 메서드

- Java의 클래스는 모두 Object로부터 상속을 받는다
- 따라서 Object에 있는 메서드들은 어떤 클래스에서도 오버라이딩이 가능하다. 대표적으로 toString()이 있다.

**`toString()`**
- 사람이 읽기 편하게 해당 개체를 문자열로 표현
- Object클래스 안의 기본 구현
  - `getClass().getName() + "@" + Integer.toHexString(hashCode())`
- Java 공식 문서는 모든 클래스에서 이 메서드를 오버라이딩 하라고 권장한다 (하지만 잘 하지 않는 편이다)

**`hashCode()`**

- 어떤 개체를 비교하는 해시값을 32 비트 정수로 반환한다
  - 동치인 두 개체는 해시값이 같다
  - 동치가 아닌 두 개체도 해시값이 같을 수 있다 (해시 충돌)
- Java의 Object클래스 안의 기본 구현은 개체의 주소를 반환하도록 되어있다.
- 주 목적은 Java가 자체 제공하는 HashMap클래스에서 사용하기 위함이다
  - 키(key) 로 사용하는 개체의 해시값이 필요하기 때문
  - 덕분에 빠른 비교용으로 사용 가능하다
    - 단 두 개체가 같지 않다는 것만 빠르게 판단 가능하다 (해시코드가 같아도 두 개체는 다를 수 있기 때문)

**`equals()`**

- 동치 비교를 위한 메서드
- 아무런 구현이 없다면 단순한 주소를 비교한다
  - 일일이 데이터를 비교하지 않는다
  - 클래스마다 같다는 의미가 다를 수 있기 때문이다.
- 클래스 속 데이터를 비교해야한다면 오버라이딩이 필요하다
  - 이때 hashCode()도 반드시 같이 오버라이딩 해야 한다
  - **equals 와 hashCode 메서드는 재정의를 같이 하거나 둘 다 하지 않거나 해야한다**
      > equals 와 hashCode 메서드 둘 중 하나만 오버라이딩 한 경우 발생할 수 있는 문제
      > ```java
      > Person p1 = new Person("John", "940629-1234567");
      > Person p2 = new Person("John", "940629-1234567");
      > 
      > HashSet<Person> set = new HashSet<>();
      > set.add(p1);
      > 
      > boolean containsP2 = set.contains(p2);
      > System.out.println("Contains p2? " + containsP2);
      > ```

---

## 패키지

![](https://i.imgur.com/9ubPNu8.png)

#### 기존 패키지 시스템의 한계

- 어플리케이션이 사용하는 클래스 목록을 찾는 공식적인 방법이 없음
  - 누락된 클래스가 있다면 실행 중에 그것을 사용하려 할 때 오류 발생
  - 따라서 사용중인 패키지에 있는 모든 클래스를 같이 배포하는게 일반적
  - 문제점
    - Java버전이 증가함에 따라 Java 자체 제공 라이브러리의 크기가 커짐
    - 안 사용하는 클래스까지 같이 배포할 경우 쓸데없이 용량이 커짐
- 패키지 안에 있는 모든 public 클래스를 아무나 사용할 수 있음
- 때로는 그 중 일부만 외부에 노출하고 싶은데 그럴 수 없음

