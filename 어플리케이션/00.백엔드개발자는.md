# 백엔드 개발자가 주로 하는 3가지
### 비즈니스 로직 짜기
### Swagger
### Test 코드 짜기 
- 비즈니스는 무조건 변경이 된다.
- 코드를 수정해도 기존의 동작이 제대로 반영이 되는지 확인 필요.
- 코드를 수정하게 되면 엣지 케이스가 발생하여 장애, 버그가 나올 수 있다. 
- 이런 부분을 미리 파악해서 방지하기 위해 테스트 코드를 작성함
# 0️⃣ 복습 방법
- 개념 깃허브로 정리
- 프로젝트를 새롭게 만들면서 공부
    - swagger
    - postman
    - h2 DB

# 1️⃣ API 설계 
- 프런트가 보고 잘 개발할 수 있도록 지원을 잘 해줘야(표준구현 해야)

- 🟨 HTTP 김영한 강의 들을 것


## REST API 구성
1. 자원(resource) - URI
2. 행위(verb) - HTTP Method
3. 표현(representations)
    ```
    [엔드포인트 구성]
    - 메소드와 URI정보로 판단
        
    DELETE /subject/{id}
    GET    /subject
    GET    /subject/{id}
    POST   /subject
    PATCH  /grade/{id}/score

    => 통일성 가져야
    => 엔드포인트만 보고 유추가 되어야
    ```

## REST API 디자인 가이드
1. URI는 정보의 자원을 표현해야
    ```
    [잘못된 예 (x)]

    GET /members/delete/1

    ㄴ URI는 delete와 같은 행위에 대한 표현이 들어가면 안됨
    ```
2. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현
    - PUT : 모든 정보 수정 시 
    - PATCH: 일부 정보 수정 시 
    ```
    [올바른 예 (o)]

    DELETE /memebers/1

    ㄴ 자원에 대한 행위는 HTTP Method로 표현
    ```

# 2️⃣ 문제를 해결하는 과정

## 2-1. 찾으려는 객체에 유니크한 컬럼이 없으면 객체 조회시 문제가 된다
- 과목을 같은 값으로 중복생성하면 grade 객체 조회시 오류 발생
    ```
    과목 생성
        {id:1, "ENG"}
        {id:2, "ENG"} 

    grade 생성로직

        //과목 조회 : subject는 기존에 있는 것인지 확인
        subjectRepository.findBySubjectType(gradeForm.getSubjectType())

        >> "ENG"가 2개라 오류발생
    }
    ```
    - 해결방안
        1. limit으로 1개만 검색되도록 한다
            - 과부하가 걸릴 수 있음
        2. 중복생성이 되지 않도록 막는다
            ```
            @Column(unique = true)
            private SubjectType subjectType
            ```
## 2-2. request폼이 상황에 따라 달라야 하는 경우
- payload가 다른 경우
    - 페이로드 : request할 때 요청하는 데이터
        > 페이로드

        >페이로드(payload)라는 단어는 운송업에서 비롯하였는데, 지급(pay)해야 하는 적화물(load)을 의미합니다. 예를 들어, 유조선 트럭이 20톤의 기름을 운반한다면 트럭의 총 무게는 차체, 운전자 등의 무게 때문에 그것보다 더 될 것이다. 이 모든 무게를 운송하는데 비용이 들지만, 고객은 오직 기름의 무게만을 지급(pay)하게 된다. 그래서 ‘pay-load’란 말이 나온 것이다
- grade를 등록할 때와 수정할 때 보여야 하는 값이 다름
    ```
    1. grade 등록

        private String studentName;
        private String subjectName;
        private Integer score;


    2. grade 수정

        private Integer score;
    ```
    - 해결방안
        1. 클래스를 별도로 관리
            - 단점 : 관리할 클래스가 늘어남
            - 주의 : 새로운 클래스가 생기면 기존 코드가 바뀔 수 있음
                - 기존 : GradeForm
                - 신규 : UpdateGradeForm
                    - GradeForm > CreateGradeForm 으로 바뀌어야
            - 장점 : 클래스가 분리되어 비즈니스 관계를 논리적으로 끊을 수 있음. 
                - 다른 클래스가 변경이 된다고 영향을 받지 않는다. 
        2. innerClass
            - 주의 : static으로 해야(자바 문법)
            - 껍데기 클래스를 만들고 그 안에 각각의 클래스를 만들어 관리

# 3️⃣ 코드 작성 주체 찾기

1. 어떤 엔티티의 어떤 값을 수정할지 정한다
2. 어떤 값을 수정할지, 어떤 값을 받을지 정한다
3. 메소드로 만든다
4. 메소드에 트랜잭션을 붙여 저장
    - 1차캐시와 데이터 값이 다르면 업데이트 됨(SpringJPA)
        - 참고 
            - JPARepository에 update가 없음
            - isNew 메소드
        
```예시 : {특정 과목에 대해 학생의 점수}를 추가할 수 있다.```

```
gradeService.java>>

public GradeResponse updateGrade(Long id, GradeForm gradeForm) {

        //테스트 조회
        Grade grade = gradeRepository.findById(id)
                .orElseThrow(() -> DomainException.notFoundRow(id));
        Student student = studentRepository.findByName(gradeForm.getStudentName())
                .orElseThrow(() -> DomainException.notFoundRow(gradeForm.getStudentName()));
        Subject subject = subjectRepository.findBySubjectType(gradeForm.getSubjectType())
                .orElseThrow(() -> DomainException.notFoundRow(gradeForm.getSubjectName()));

        //테스트계정 수정                                          
        Grade updateGrade = Grade.of(student, subject, gradeForm.getScore());

        //테스트계정 저장
        gradeRepository.save(updateGrade);
        return new GradeResponse(updateGrade);
    }
```
-> 
```
grade.java>>

public void updateScore(int score) {
    this.score = score;
}

[gradeService.java]

public void updateGrade(Long id, GradeRequest.UpdateGradeForm updateGradeForm) {
    //테스트 조회
    Grade grade = gradeRepository.findById(id)
            .orElseThrow(() -> DomainException.notFoundRow(id));

    grade.updateScore(updateGradeForm.getScore());

    //gradeRepository.save(grade);
}
```