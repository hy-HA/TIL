# 계층구조별 필수개념_리포지토리와 서비스와 컨트롤러

# 리포지토리

### JPA리포지토리 상속받기
- JPA리포지토리를 사용하면 Optional로 받아옴. 
- 반환값이 Optional. Optional 하나의 컬렉션이라 생각하면됨.
- JPA 리포지토리는 제네릭 클래스
    - 상속 시 타입 명시해야 함


### 🟨 옵셔널과 예외처리
- Optional.orElseThrow() 
#### Sample Code : 서비스 클래스에서 옵셔널 예외처리하기
```java
public void deleteStudent(Long id){
        Student student = studentRepository.findById(id)
                .orElseThrow(() -> DomainException.notFoundRow(id));
    }
```
## 익셉션

### 3-1.런타임 익셉션
- 해당 익셉션이 발생하는 경우
    - 배열에 index값 넘어설때
    - 널 발생
- => 익셉션이 발생하면 롤백마크가 찍힘 > 상위에까지 전달됨.

### 3-2.일반 익셉션
- 에러잡을때 try catch로 잡아야

## 4. 커스텀 익셉션

## 5. 🟨 쿼리 메소드

- [참고](https://kihwan95.tistory.com/5)

- 필드명과 동일하게 설정해야
    ```
    [SubjectRepository.java]

    public interface SubjectRepository extends JpaRepository<Subject, Long> {

    Optional<Subject> findBySubjectType(SubjectType subjectType);
    }

    
    [subject.java]

    private Long id;
    private SubjectType subjectType;
    private int score;
    
    >> subject에 subjectType을 찾는경우 리포지토리에서 변수명을 subject의 필드명과 동일하게 설정해야
    ```


# 서비스

### 🟨 필드주입보다는 생성자 주입
```
    @Autowired StudentRepository studentRepository;    //(X)

    private final StudentRepository studentRepository; //(O)
```

## 비즈니스 로직 생성

### 답변용 학생계정(StudentResponse) 생성
```
@Transactional
public StudentResponse createStudent(StudentRequest request) {
    Student student = Student.builder()
            .name(request.getName())
            .score(request.getScore())
            .build();

    return new StudentResponse(studentRepository.save(student));
}
```

### 답변용 학생계정(StudentResponse) 리스트 조회
```
@Transactional(readOnly = true)
public List<StudentResponse> getStudentList() {
    List<StudentResponse> result = new ArrayList<>();
    for (Student student : studentRepository.findAll()) {
        result.add(new StudentResponse(student));
    }

    return result;

    /*return studentRepository.findAll()
            .stream()
            .map(StudentResponse::new)
            .collect(Collectors.toList());*/
}
```
### 답변용 학생계정(StudentResponse) 조회
```
@Transactional(readOnly = true)
public StudentResponse getStudent(Long id) {
    Student student = studentRepository.findById(id)
            .orElseThrow(() -> DomainException.notFoundRow(id));

    return new StudentResponse(student);
}
```

# 컨트롤러


## 컨트롤러의 특징
1. 파라미터에 어노테이션을 붙여야
    - @RequestBody
    - @PathVariable
2. 주소를 알려줘야 
    - @PatchMapping("/grade/{id}/score)
3. 컨트롤러 에노테이션
    - @ResponseBody
    - @RequiredArgsConstructor
    - @RequestMapping("/student")

## RestController vs controller
1. @Controller의 역할
    - 뷰에 표시될 데이터가 있는 Model 객체를 만들고 올바른 뷰를 선택하는 일을 담당
    - @ResponseBody를 사용
        - HTTP Response Body에 데이터를 담아 요청을 완료할 수 있음
        - RESTful 웹 서비스에 대한 응답에 매우 유용
        - 왜냐하면 뷰를 반환하는 대신 데이터를 반환하기 때문
2. @RestController
    - @Controller와 @ResponseBody의 조합
    - RESTful 웹 서비스를 보다 쉽게 개발할 수 있도록 Spring 4.0에서 추가
    - 단순히 객체만을 반환하고 객체 데이터는 JSON 또는 XML 형식으로 HTTP 응답에 담아서 전송
- responsebody : 바디에 데이터를 바로 전달 가능. 

## ResponseEntity
- HttpEntity를 상속받고 사용자의 응답 데이터가 포함된 클래스라 아래를 포함
    1. HttpStatus
    2. HttpHeaders
        - status 코드(200,400 등)
    3. HttpBody
        - 응닶값

- 자동으로 객체를 넣었을때 state코드 응답값을 통일된 형태로 보내주는 

## 람다식 
- stream
