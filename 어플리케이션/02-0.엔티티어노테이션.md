## @Id @Coulumn

### @Id
- 해당 컬럼을 PK로 설정한다.

### @Column 
- 컬럼의 조건들을 괄호안에 걸어줄 수 있다. (이 어노테이션을 쓰지 않아도 컬럼으로 자동 인식한다.)

### @Table
- db 테이블과 연결시켜줌
    - 예를 들어서 실제 디비의 테이블 네임은 abc 인데, 엔티티의 이름은 abcd 라고 하면 자동으로 매칭될 수 없다.
    - 그래서 보통은 엔티티와 테이블네임을 일치시켜주는 게 아주 일반적인 것으로 알고 있는데, 경우에 따라 그럴 수 없기도 하다.
    - 바로 그럴때에 @Table 어노테이션을 사용해서 테이블과 엔티티를 매칭시켜준다.

### @Getter
- 엔티티의 필드를 조회해야할 경우는 반드시 있기 때문에 @Getter는 당연히 사용

### @NoArgsConstructor
- 기본 생성자를 생성해준다.
    - 이 경우 초기값 세팅이 필요한 final 변수가 있을 경우 컴파일 에러가 발생함으로 주의한다.
- java의 ORM 기술인 JPA는 기본 스펙상 기본 생성자를 요구(없으면 컴파일 에러남)
    - 마치 Querydsl 생성할때 super 클래스로 도메인 클래스 넘겨줘야하는 것과 같다.
    - 즉, 그냥 그 기술을 만들어놓은 사람들이 설계상의 이유로 그렇게 해놨고 그걸 지켜야 한다.

#### @NoArgsConstructor( access = AccessLevel.PROTECTED)

1. ORM 기술이라는 것은 기본적으로 영속성 이라는 개념이 있음
    - 간단히 말해, 데이터베이스의 실제 데이터와 그 엔티티가 일관된 상태를 유지하고 있어야한다는 것
    - 그런 이유로 엔티티에는 @Setter 어노테이션을 붙이지 않는다.
        - 각 필드들에 대해 일관성을 유지해야하는데..
        - 언제, 어느 코드에서, 누가, set() 를 여는 순간 그게 다 깨지기 때문이다.
    - 그럼에도 어쨌든 값을 넣어주긴 해야되니까 생성자를 쓰는 것
        - 실제로 패턴상 안전한 방법
    - 그래서 @NoArgsConstructor 를 활용해서 기본생성자를 추가하되, 접근제한을 걸어서 안전성도 높이는 것이다.

2. 왜 protected 이지? private 이 아니고?
    - 위에서 JPA는 기본 생성자를 요구한다고 했었다.
    - 그런 JPA가 받아들일 수 있는 최대 수준의 생성자가 Protected 이기 때문
    - 즉, 할 수 있는 선에서 최대한의 접근 제한을 건 것

### @AllArgsConstructor 
- 전체 변수를 생성하는 생성자를 만들어준다.
- 즉, name, age, email 이라는 필드가 있으면 그 3개에 대한 전체 생성자라는 뜻

#### 빌더 패턴의 특징
- 빌더 패턴은 기본적으로 빌더 어노테이션이 적용된 전체 필드에 대한 값을 요구
- 그래서 생성자가 반드시 필요