# ENUM

# 열거(enum) 타입
- 제한된 값만 사용할 수 있는 타입
- 클래스처럼 보이게 하는 `상수`
    - 상수 : 값을 변경할 수 없는 것
- 서로 관련있는 상수들끼리 모아 `상수들을 대표하는 타입`을 정의
- exception관리 위함
    - 존재하지 않는 과목명이 insert되지 않도록(null)
- [참고](https://www.opentutorials.org/module/1226/8025)


# enum클래스 정의와 사용
- KOR, MATH, ENG : 상수(수식에서 변하지 않는 값)
- 각 상수들은 `클래스명.name`으로 얻어올 수 있음
### 열거타입 정의 1
```java
SubjectType.java>>

public enum SubjectType {
    KOR,ENG,MATH
}
```
### 열거타입 사용 🧩
```java
Subject.java>>

    //열거타입 변수 선언 🧩
    SubjectType subjetType;  

    //열거값 대입 🧩
    subjectType = SubjectType.KOR; 

    //열거값을 String으로 반환하는 메소드
    public String getSubjectType(){
        return subjectType.name();
    }

    //지양해야 하는 코드
    public SubjectType getSubjectType() {
        return subjectType;
    }

    //Subject 생성자
    @Builder
    public Subject(String subject){
        initSubjectType(subject);
        this.isDeleted = false;
    }

    private void initSubjectType(String subject) {

        try {

            🧩
            this.subjectType = SubjectType.valueOf(subject);

        } catch (IllegalArgumentException e) {
            
            🧩
            throw TypeException.of("과목", subject);
        }
    }
```
### 참고. 열거타입을 사용한 클래스를 반환하는 DTO객체
```java
public class SubjectResponse {

    private Long id;
    private String subjectType;

    public SubjectResponse(Subject subject){
        this.id = subject.getId();
        this.subjectType = subject.getSubjectType();
    }
}
```
---
### 열거타입 정의 2_출력문자 정의
- 열거형 상수를 다른 값과 연결하기
- 이때는 세미콜론 붙여야 함

```java
SubjectType.java>>

public enum SubjectType {

    KOR("국어", 1), MATH("수학", 2), ENG("영어", 3);
    
    private String description;
    private int value;

    //enum에서 생성자 같은 역할. 
    //이걸 작성 해야 컴파일 오류가 안남 🟨 왜?
    SubjectType(String description, int value) {
        this.value = value;
        this.description = description;
    }
}
```

# 2. 외부 클래스에서 enum타입을 필드/메소드로 사용
## 필드에 enum타입을 선언
### SampleCode
```java
Subject.java>>

@Enumerated(value = EnumType.STRING)
@Column(name = "subject_type", unique = true)
private SubjectType subjectType;

```
### @Enumerated
- @Enumerated
    - 테이블에 저장되는 타입을 지정해주는 어노테이션
    - `@Enumerated(value = EnumType.STRING)`
- ORDINAL, STRING
    - EnumType.ORDINAL : enum 순서 값을 DB에 저장
    - EnumType.STRING : enum 이름을 DB에 저장
### @Column
- @Column
    - db컬럼과 비교시 필요한 부분들을 정하는 어노테이션
    - name,unique 등의 속성이 있다
    - `@Column(name = "subject_type", unique = true)`

## 외부에서 enum타입을 사용하도록 메소드 선언
- 디미터 법칙 : 객체 타입을 String으로 반환하여 사용시 .을 최대한 적게 찍는다.
### name()메소드 : enum타입을 String으로 반환
- 사용법 
    - `enum클래스.name()`
```java
//필드
@Enumerated(value = EnumType.STRING)
@Column(name = "subject_type", unique = true)
private SubjectType subjectType;

//String으로 변환하는 메소드
public String getSubjectType(){
    return subjectType.name();
}
```
### valueOf()메소드 : 생성자를 만들때 enum타입을 String으로 반환
- 사용법
    - `enum클래스.valueOf(Stirng타입 변수)`
```java
@Builder
public Subject(String subjectType){

    //valueOf메소드를 사용하면 예외처리를 해주어야 함. 자세한건 밑에.
    this.subjectType= SubjectType.valueOf(subjectType);
}
```

# 3. 응답 객체에서 사용하기
- [ ] 사용되는 어노테이션 왜 필요한지 확인 필요 🟨
    - [여기다가 정리](https://hackmd.io/_jk5q_29RduLoBBsuHH48A)
```java
SubjectResponse.java>>

public SubjectResponse(Subject subject) {
        this.id = subject.getId();

        this.subject = subject.getSubjectType();
    }
```

# 4. Enum 메소드
## enum객체 생성 시
### 1. Enum클래스명.상수명
- enum형 객체를 만들어서 가져옴
    - ```SubjectType.ENG```
## enum객체 사용 시
### 2. valueOf(String arg) 
- 전달된 문자열과 일치하는 상수를 반환
- 값이 없으면 예외(IllegalArgumentException) 발생
    - 대소문자 구분함
    - 정의된 타입만 사용가능
- SubjectType.valueOf("ENG")
> 참고
> valueOf도 정적 팩토리 메소드의 일종
> 미리 생성된 객체를 "조회"하는 메서드라 팩토리의 역할을 하지는 않지만, 외부에서 원하는 객체를 반환해주므로 결과적으로는 정적 팩토리 메서드라고 간주해도 좋다. 
#### valueOf메소드 예외처리
```java
try {

    this.subjectType = SubjectType.valueOf(subject);

} catch (IllegalArgumentException e) {

    throw TypeException.of("과목", subject);
}
```
#### 커스텀예외 🟨
```java
public class TypeException extends RuntimeException {

    private TypeException(String message) {
        super(message);
    }

    public static TypeException of(String typeName, String name) {
        return new TypeException(String.format("[%s] 해당 이름을 가진 [%s]이/가 존재하지 않습니다.", typeName, name));
    }
}
```
### 3. values() 
- enum의 요소들을 순서대로 enum타입의 배열로 리턴
- ```SubjectType.values()```

### 4. ordinal()
- 원소에 열거된 순서를 정수값으로 리턴
    



