| 잘 설계한 ORM어플리케이션은 매핑한 테이블의 수가 클래스의 수보다 더 많다

| 01.JPA기본 > JPA데이터타입 참고 
# Embedded 타입
- 하이버네이트에서 임베디드 타입을 컴포넌트 타입이라 함 ⚠️

### 이유
- 코드의 재사용
- 높은 응집도

### 사용법
- 기본 생성자가 필수
- @Embedded
    - 값 타입을 사용하는 곳에 표시
- @Embeddable
    - 값 타입을 정의하는 곳에 표시
```java
@Embeddable
@Getter
public class Address {
    private String city;
    private String street;
    private String zipcode;
    }

    @Builder
    public Address(String city,String street,String zipcode){
        this.city=city;
        this.street=street;
        this.zipcode=zipcode;
    }
}
```
```java
@Entity
@Getter 
public class Member {
    @Id
    @GeneratedValue
    @Column(name = "member_id")
    private Long id;

    private String name;

    @Embedded
    private Address address;

}
```
## @Builder의 원리
- 파라미터 변수명으로 메소드 생성
- StudentRequest > Student
```java
@Transactional
public StudentResponse createStudent(StudentRequest request) {
    Student student = Student.builder()
            .studentName(request.getStudentName())
            //.address(request.getCity(),request.getStreet(), request.getZipcode())
            .address(new Address(request.getCity(), request.getStreet(), request.getZipcode()))
            .build();

    studentRepository.save(student);

    return new StudentResponse(student);
}
```
## @delegate
- 디미터를 해결 할 수 있는 어노테이션
- 해당 어노테이션이 붙은 클래스의 퍼블릭 메소드를, 필드에 선언된 위치에 만들어줌
```java
public class Student {

    @Delegate
    @Embedded
    private Address address;
}
---
@Data
public class StudentResponse {

    public StudentResponse(Student student){
        this.id = student.getId();
        this.studentName = student.getStudentName();
        this.city = student.getCity();
        this.street = student.getStreet();
        this.zipcode = student.getZipcode();
        //아래처럼 작성하지 않아도 됨
        // this.city = student.getAddress.getCity();
        // this.street = student.getAddress.getStreet();
        // this.zipcode = student.getAddress.getZipcode();
    }
}
```
#  Mapper
- 엔티티, request, response, 코멘드, result, info 등 보통 5개 정도 됨
    - mapper 이용하는게 편함
### 특징
- 컴파일 시점에 코드를 생성하여 런타임에서 안정성을 보장
- 다른 매핑 라이브러리보다 속도가 빠름
- 어노테이션 processor를 이용해 객체 간 매핑을 자동으로 제공
- 다만, 롬복 라이브러리보다 의존성 추가가 먼저되어야 함
    - mapstruct는 롬복의 게터, 세터, 빌더를 이용하여 생성됨
    - 따라서, 롬복보다 먼저 의존성이 선언된 경우 실행할 수 없음
### 주의점
- 자동으로 변환을 해주기 때문에 규약대로 안하면 잘못 생성됨
- 매퍼를 수정하면 재빌드 해주어야!
- 변환되는 필드명들은 각각 동일하게 설정해야

## 사용법
## 1. mapstruct 의존성 추가
```
//lombok
annotationProcessor 'org.projectlombok:lombok-mapstruct-binding:0.2.0' // v1.18.16+ 부터

// mapstruct
implementation 'org.mapstruct:mapstruct:1.4.2.Final'
annotationProcessor 'org.mapstruct:mapstruct-processor:1.4.2.Final'
```
## 2.  mapper 인터페이스 생성
- 메소드명은 자유롭게 
- @Mapper(componentModel = "spring") 어노테이션 한줄로 스프링 컨테이너가 실행될 때 bean으로 등록
```java
@Mapper(componentModel = "spring")
public interface StudentMapper {

     Student toStudent2(StudentForm studentForm);

     StudentResponse toStudentResponse2(Student student);

     Address toAddress2(StudentForm.StudentAddressForm addressForm);

     StudentResponse.StudentAddressResponse toStudentAddressResponse1(Address address);
}
```
## 3. build하기
- 구현체를 만들어줌
- 수정하게되면 재빌드해주어야!

## 4. mapper를 적용하는 클래스 
1. @builder, @Getter 선언
2. request, response클래스에 Builder클래스 생성
### Sample. Address > StudentAddressResponse
```java
public class Address {
    private String city;
    private String street;
    private String zipcode;
}
```
```java
public class StudentResponse {

    private Long id;
    private String studentName;
    private StudentAddressResponse address;

    @Data
    @Builder
    @AllArgsConstructor
    @NoArgsConstructor
    public static class StudentAddressResponse {
        //이러면 mapper가 정상적으로 매핑되지 않는다!
        //각각 city, street, zipcode로 설정해주어야!
        private String address1;
        private String address2;
        private String address3;
    }

}
```

## 매핑 규칙을 직접 지정하기
- 타겟 필드와 소스 필드를 동일하게 맞추기 어려운경우 사용
### 매퍼 클래스의 메소드에 @Mapping 적용
- @Mapping(target = "address1", source = "city")
    - city로 들어온 필드를 address1으로 매핑해준다
```java
@Mapper(componentModel = "spring")
public interface StudentMapper {

    Student toStudent(StudentForm studentForm);

    StudentResponse toStudentResponse(Student student);

    Address toAddress(StudentForm.StudentAddressForm addressForm);

    @Mapping(target = "address1", source = "city")
    @Mapping(target = "address2", source = "street")
    @Mapping(target = "address3", source = "zipcode")
    StudentResponse.StudentAddressResponse toStudentAddressResponse(Address address);
}
```

## 그외
- @Mapping내 주요 메소드
    - ignore, target, source