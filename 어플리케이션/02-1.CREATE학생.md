# 학생 생성하기
- [어노테이션 참조](https://hackmd.io/_jk5q_29RduLoBBsuHH48A)
- validation
    1. 커스텀 익셈션 클래스 생성
    2. request 객체에서 @NotNull 어노테이션으로 검사
    3. 서비스에서 예외처리


# 도메인

### 1. 클래스 어노테이션
- @Getter | @NoArgsConstructor | @Entity | @Table(name="student")
### 2. Primary Key
- entity는 primary키가 필수로 필요
### 3. 생성자 선언
- request객체에서 String필드를 @RequestBody로 받아서 student객체 생성후 반환
    - 클래스 단계 참고
```java
@Getter
@NoArgsConstructor
@Entity
@Table(name="student")
public class Student {
    
    //entity는 primary키가 필수로 필요
    @Id @GeneratedValue
    private Long id;

    private String studentName;

    //request객체에서 String필드를 받아서 student객체 생성후 반환
    @Builder
    public Student(String name){
        this.studentName = name;
    }
}
```
# DTO
## Request 객체
### 클래스 어노테이션
- @Data | @AllArgsConstructor | @NoArgsConstructor
### validation  `(validation)`
- @NotNull   
```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class StudentForm {

    //validation
    @NotNull
    private String studentName;
}
```
## Response 객체
### 클래스 어노테이션 
- 상동
### Primary Key 필드
- Entity객체를 받아 반환하므로 request 객체와 다르게 id필드가 필요
### 반환객체 생성자
- Entity객체를 받아서 Restpnse 객체로 변환


```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class StudentResponse {

    private Long id;
    private String studentName;

    public StudentResponse(Student request) {
        this.id = request.getId();
        this.studentName = request.getStudentName();
    }
}
```
# 리포지토리
- JAP리포지토리는 제네릭클래스
    - 파라미터로 객체 타입 지정해줘야 오류가 나지 않는다
```java
public interface StudentRepository extends JpaRepository<Student,Long> {}
```

# 서비스
1. Request객체를 전달받아서(StudentForm)
    - 필드 : studentName
2. Request객체 예외처리 해주고 `(validation)`
3. 학생객체를 만들어주고(Student)
    - builder 사용
    - 이때 id는 자동 생성됨(@Id, @GeneratedValue)
4. 리포지토리에 저장하고(이때 저장타입은 Student)
    - 리포지토리는 제네릭 클래스를 상속받고 있으므로 
    - 리포지토리에서 선언한 타입으로 전달해주어야함
5. response객체로 변환해서 전달(StudentResponse)

```java
@Service
@RequiredArgsConstructor
public class StudentService {
    private final StudentRepository studentRepository;

    @Transactional
    public StudentResponse createStudent(StudentForm request) {

        //validation
        if(request.getStudentName() == null){
            throw new NullException(request.getName());
        }
        //학생 객체 생성해서 request에서 받은 내용 변환해주기
        Student student = Student.builder()
                .name(request.getStudentName())
                .build();
        //학생 객체를 리포지토리에 저장(리포지토리는 학생객체로 받기 때문)
        studentRepository.save(student);

        //리포지토리에 저장한 학생객체를 response객체로 담아서 반환
        return new StudentResponse(student);
    }
```

# 커스텀 익셉션
- `(validation)`
```java
@ResponseStatus(code = HttpStatus.INTERNAL_SERVER_ERROR, reason = "null값은 허용하지 않음")
public class NullException extends RuntimeException {

    public NullException(String message) {
        super(message);
    }

    public static NullException notNull() {
        return new NullException("공백일 수 없습니다");
    }
}

```

# 클래스 🟨
```java
@RestController
@RequiredArgsConstructor
public class SubjectController {
    
    private final SubjectService subjectService;
    
    @ResponseBody
    @PostMapping("/subject")
    public ResponseEntity<SubjectResponse> createSubject(@RequestBody SubjectForm request){
        SubjectResponse subjectResponse = subjectService.createSubject(request);
        return ResponseEntity.ok(subjectResponse);
    }
}
```
### 클래스 어노테이션
- @RestController | @RequiredArgsConstructor

### 메소드 어노테이션
- @ResponseBody | @PostMapping("/subject")
### 파라미터 어노테이션
- @RequestBody
### 반환객체
#### ResponseEntity
- ResponseEntity를 사용하는 이유 🟨
    - `ResponseEntity.status(HttpStatus.NO_CONTENT).build()`
    - `ResponseEntity.ok(subjectResponse)`

