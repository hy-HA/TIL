# 계층구조별 필수개념_도메인과 DTO

# 도메인

### 1. setter는 사용하지 말 것
1. 도메인 로직이 분산되는 것을 막기 위해
2. 객체 필드값을 수정하는 목적에 맞게 메서드를 정의하기 위해
    -  [참고](https://velog.io/@backfox/setter-%EC%93%B0%EC%A7%80-%EB%A7%90%EB%9D%BC%EA%B3%A0%EB%A7%8C-%ED%95%98%EA%B3%A0-%EA%B0%80%EB%B2%84%EB%A6%AC%EB%A9%B4-%EC%96%B4%EB%96%A1%ED%95%B4%EC%9A%94)
### 2. 의존성 주입 3가지 방법
- [의존성주입](https://hackmd.io/R4xP8rDAQbG8sC2tJrdO0g)
1. 필드 주입
    - [참고 : 상속과 컴포지션](https://hackmd.io/ax72ukQsTbWsVRO2qun29Q) 
2. 생성자 주입
3. 수정자 주입

##  생성자 대안들
- 정적 팩토리 메소드
- Builder 패턴
- [클래스 객체 생성방법](https://hackmd.io/HZaP6V5VTEKd15hiKcXyYQ)

# DTO
- 화면페이지에서 요구사항이 계속 바뀌니 도메인에서 필요한 부분만 받아오기위해

### 어노테이션
- @Data : 아래 어노테이션을 한번에 설정
    - @Getter, @Setter
    - @RequiredArgsConstructor
    - @ToString
    - @EqualsAndHashCode 


- @AllArgsConstructor : 모든 필드값을 파라미터로 받는 생성자 생성
- @NoArgsConstructor : 파라미터가 없는 기본 생성자 생성
- @RequiredArgsConstructor : final이나 @NonNull인 필드 값만 파라미터로 받는 생성자 생성


### DTO request와 response 두개로 관리. 왜?

- 너는 어떤 도메인에서 일해? 
    - A : 이커머스, 금융권, 보안 
    - A-1 : 상품을 관리하는/주문/결제

- 장점
    - 변경사항이 생겼을 때 같은 객체를 쓰게되면 다 같이 변경이 됨
    - 의존성을 끊어주는 것이 중요. 
    - DDD 개념이 그래서 나오게 된 것. 

- 단점
    - dto 객체가 많아지면, 레이어가 많아지면, 변환로직(컨트롤러에서 서비스로 넘어갈때)
    - 컨버터 비용이 늘어난다. A객체에서 B객체로 변환하는 로직
    - mapstruct
