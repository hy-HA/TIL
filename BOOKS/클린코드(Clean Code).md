클린 코드(Clean Code)
=====

목차
---

1. 추천사&들어가면서
2. 깨끗한 코드
3. 의미 있는 이름
4. 함수
5. 주석
6. 형식 맞추기
7. 객체와 자료구조
8. 오류 처리
***
추천사&들어가면서
---
1장 깨끗한 코드
---
> 기억하고 싶은 책 내용

* 추천사
    * 사소한 곳에서 발휘하는 정직은 사소하지 않다. / 신은 세세함에 깃들어 있다. 
    * 소프트웨어는 80% 이상이 소위 "유지보수"다. 
    * 진정으로 책임있는 개발자라면 제품 생명주기까지 고려해야 한다. 
    * 품질은 하늘에서 뚝 떨어진 위대한 방법론이 아니라 사심없이 기울이는 무수한 관심에서 얻어진다. 간단하다고 해서 단순하거나 쉽다는 의미는 아니다. 
    * 읽기 좋은 코드는 돌아가는 코드만큼이나 중요하다. 
    * 첫 아이 이름을 짓듯이 심사숙고해서 변수 이름을 지어야 한다. 
* 들어가면서 
    * 이 책의 구조
        * 깨끗한 코드를 작성하는 원칙 : 2~10장(아마)
        * 사례 연구 : 11장~16장(아마)
        * 결말 : 17장  
    * 깨끗한 코드는 고생을 해야 한다. 
        * 스스로 연습하고 실패도 맛봐야 한다. 남들이 시도하다가 실패하는 모습도 봐야 한다. 결정을 내리느라 고민하는 모습, 잘못된 결정으로 대가를 치르는 모습도 봐야 한다. 
        * 코드를 분석하고 고치며 우리가 느끼는 감정을 이해하고, 그렇게 느끼는 이유와 그렇게 고치는 이유를 잡아내려 애써야 한다. 코드를 짜고, 읽고, 정리하는 관점에서 우리가 생각하는 방식을 묘사한 지식 기반을 구축할 수 있다.
* 1장 깨끗한 코드
    * 깨끗한 코드는 중요하다. 그리고 프로그래머는 코드를 깨끗이 하는 것을 사수해야 한다. 
        * 코드는 요구사항을 상세히 표현하는 수단. 
        * 나쁜 코드로 치르는 대가 : 코드를 고칠 때마다 엉뚱한 곳에서 문제가 생김. 원대한 재설계의 꿈을 가지고 두 팀이 경주를 시작. 때때로 경주는 아주 오랫동안 이어지고 타이거 팀원들은 모두 팀을 떠나고 새로운 팀원들이 새 시스템을 설계하자고 한다. 
        * 태도 : 좋은 코드를 사수하는 일은 바로 프로그래머들의 책임이다.
    * 깨끗한 코드란
        * 우아한 : 보는 사람에게 즐거움을 선사
        * 효율 : CPU자원을 낭비하지 않는
        * 나쁜 코드를 유혹하지 않는 : 깨진 창문 이론
        * 철저한 오류 처리 
        * 단순 : 한가지에 집중하는
        * 가독성 : 읽기 쉬운
        * 수정 용이 : 다른 사람이 고치기 쉬운
        * 표현력 높이기 : 제대로 표현할 것. 
        * 작게 추상화 : 초반부터 간단한 추상화 고려
        * 짐작대로 돌아가는 코드
> 소감 및 생각
* 깨끗한 코드를 작성하기 위한 세심한 태도를 굉장히 강조하고 있다. 
* 그 이유는 소프트웨어의 80% 이상이 "유지보수"이기 때문이며, 유지보수가 원활하게 진행되기 위해서는 깨끗한 코드가 필수이기 때문이다. 
* 그 깨끗한 코드는 쉽게 얻어지는 것이 아니라, 스스로(혹은 옆에서) 실패하고 고생하며, 그 감정을 이해하고, 그렇게 느끼는 이유와 결과적으로 마무리된 코드의 이유를 잡아내려 애쓰는 과정에서 얻어진다. 
* 쉽지는 않겠지만, 제대로 일할 수 있는 원리서를 만난 것 같아서 기쁘다. 
> 새롭게 배운 개념
* 소프트웨어의 80%는 "유지보수"이기 때문에, 유지보수를 원할하게 하려면 깨끗한 코드를 사수해야 한다.  
* 깨끗한 코드란, 단순하고, 읽기 쉽고, 수정하기 쉽고, 명료하고, 이해하기 쉬운 코드. 

***
2장 의미있는 이름
---
> 기억하고 싶은 책 내용
* 클래스 이름 : 명사나 명사구가 적합
* 메서드 이름 : 동사나 동사구가 적합
    * 접근자 (accessor) : get~
    * 변경자 (mutator) : set~
    * 조건자 (predicate) : is~
* 해법 영영에서 가져온 이름을 사용하라
    * 기술 개념에는 기술 이름이 가장 적합. (ex. queue, stack)
* 문제 영역에서 가져온 이름을 사용하라
    * 적절한 프로그래머 용어가 없다면 문제 영역에서 이름을 가져온다. 
    * 기술 개념이 아닌 문제 영역 개념과 관련이 깊을 경우 이에 해당.
> 소감 및 생각
* 오랜 기간 급격히 발전해오면서 규칙들이 종종 변한 것 같다. 초심자의 입장에서는 당연한 말을 쓴 것 같은데, 막상 여러 블로그 글을 읽어보니 이런 규칙들이 지켜지키 힘든 상황들이 많은 듯하다. 
* 변수의 가독성과 업무의 효율성을 잘 저울질하면서 변수의 가독성을 높이는 것이 프로그래머의 책임이라는 것을 또하나 배웠다. 
> 새롭게 배운 개념
* 변수와 메소드 네이밍에 관한 15가지 모범사레
    * https://www.mimul.com/blog/15-best-practices-of-variable-method/
* 문자 인코딩과 디코딩 
    * 컴퓨터는 문자를 인식할 수 없기 때문에 숫자로 변환되어 저장됨. 변환해주기 위한 기준이 문자코드. 대표적으로 ASCII코드 또는 유니코드가 있음. 문자코드를 기준으로 문자를 코드로 변환하는 것을 문자 인코딩, 코드를 문자로 변환하는 것을 문자 디코딩. 
    * 인코딩/디코딩은 정보의 형태나 형식을 변환하는 처리에 대해 표준화하고 보안, 처리속도 향상, 저장 공간 절약 등의 목적으로 사용. 
* 인코딩 
    * 이름에 부가 정보를 덧붙이는 것. 데이터 유형과 범위 정보까지 이름에 넣으면 해독과 발음이 어려워짐.  
    * 인코딩 예시 : https://blog.naver.com/n_cloudplatform/222508039135
    * 헝가리안 표기법
        * 변수 및 함수의 인자 이름 앞에 데이터 타입을 명시하는 코딩 규칙. 
        * 정적 타입 언어가 대세인 시절에 나온 것이라, 파이썬/자바스크립트처럼 동적 타입 언어에는 큰 의미가 없음. 
        * 디스플레이 화면이 커지면서 한 눈에 볼 수 있는 코드의 양이 많아지고, IDE가 눈부시게 발전하면서 마우스 커서만 올리면 해당 변수의 데이터 타입이 나오는 덕에 헝가리안 표기법은 바로 구식으로 변함. 
    * 멤버 변수 접두어 : m_을 멤버 변수에 붙이는 것은 비효율적일 수 있음. (필요한 경우엔 사용 가능)
***    
3장 함수
---
> 기억하고 싶은 책 내용
* 마스터 프로그래머는 시스템을 구현할 프로그램이 아니라 풀어갈 이야기로 여긴다. 프로그래밍 언어라는 수단을 사용해 좀 더 풍부하고 표현력이 강한 언어를 만들어 이야기를 풀어간다. 
* 소프트웨어를 짜는 행위는 글짓기와 비슷하다. 초안은 대개 서투르고 어수선하므로 원하는 대로 읽힐 때까지 말을 다듬고 문장을 고치고 문단을 정리한다. 
* 반복하지 마라. 
* 작게 만들고 한가지만 해라. 
    * 오류 코드보다 예외를 사용하라
    * 명령과 조회를 분리하라 
    * 부수 효과를 일으키지 말라. 남몰래 다른 짓을 하는 것. 교활하고 해로운 거짓말이다. 
    * 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우다. 
        * 인수는 어렵다. 인수는 개념을 이해하기 어렵게 만든다. 
* 서술적인 이름을 사용하라 
> 소감 및 생각
* 카카오톡과 크롬앱 클론 강의만 들은 상태라 책 안의 코딩 내용을 완전히 이해하기가 어렵다. 아직은 앞으로 이런 고민들을 하겠구나 하고 대략적인 감을 익히는 단계로 대략의 키워드들만 기억해야겠다. 프로그래밍이 글쓰기와 비슷하다는 개념으로 더더욱 프로그래밍에 애정을 느끼게 되었다.  
> 새롭게 배운 개념
* FitNess :  오픈 소스 테스트 도구
* JUnit : 오픈 소스 단위 테스트 도구
* LOGO 언어에서 사용하는 키워드 TO는 루비나 파이썬에서 사용하는 'def'와 똑같다. 

***    
4장 주석
---
> 기억하고 싶은 책 내용
* 주석은 오래될수록 코드에서 멀어진다. 이유는 단순하다. 프로그래머들이 주석을 유지하고 보수하기란 현실적으로 불가능하니까. 코드는 변화하고 진화한다. 일부가 여기서 저기로 옮겨지기도 한다. 불행히도 주석이 언제나 코드를 따라가지는 않는다. 아니, 따라가지 못한다. 
* 코드로 의도를 표현하라. 주석은 나쁜코드를 보완하지 못한다. 
* 나쁜 주석
    * 주절거리는 주석. 같은 이야기를 중복하는 주석. 
    * 오해할 여지가 있는 주석. 
    * 의무적으로 다는 주석.
    * 이력을 기록하는 주석. 이제는 소스 코드 관리 시스템이 있다.
    * 있으나 마나 한 주석. 지나친 참견은 개발자가 주석을 무시하는 습관에 빠지게 한다. 
> 소감 및 생각
* 적당한 조언은 효율적으로 일을 하는데 도움을 주지만 지나친 간섭은 오히려 그 의도를 해치게 된다. 더 완벽하게 하고 싶은 욕심에 주석을 사용하고 싶더라도 프로그래밍의 핵심은 쉽고 단순한 함수 짜기이고, 필요시에만 주석을 다는 습관을 기르는 연습을 해야겠다. 
> 새롭게 배운 개념
* 소스 코드 관리(source code management, SCM)
    * 동일한 정보에 대한 여러 버전을 관리하는 것. 팀 단위로 개발 중인 소스 코드나, 청사진 같은 설계도 등의 디지털 문서를 관리하는데 사용됨.
    * 소프트웨어 엔지니어링에서는 일반적인 소프트웨어 소스 코드만을 관리하는 내역을 주로 버전 관리라고 정의. 
    일반적으로 산업 공학이나 이전 생산 기반 제조 공학 등에서 소프트웨어 쪽으로 넘어오는 학문적 관심에 의해 이전 생산 공학에서 사용하던 개념을 가져오게 되었고, 그에따라 버전 관리(Software Version Management)와 형상 관리(Software Configuration Management)의 개념들이 따라왔음.

***    
더러운 코드 고치기 미션
---
* 검색가능한 이름을 사용 - 이름이 정해져 있지 않은 상수.
    * 우리는 작성할 코드보다 읽을 코드가 더 많음. 그렇기 때문에 코드를 읽기 쉽고 검색가능하게 작성해야 함. 그렇지 않으면 코드를 이해하려고 하는 사람들에게 큰 어려움을 줌. 
    * buddy.js 그리고 ESLint 와 같은 도구들이 이름이 정해져있지 않은 상수들을 발견하고 고칠 수 있게 도와줌. 
    * 참고 : https://github.com/qkraudghgh/clean-code-javascript-ko

    안좋은 예 : 
    ```
    // What the heck is 86400000 for?
    setTimeout(blastOff, 86400000);
    ```
    좋은 예 : 
    ```
    const MILLISECONDS_IN_A_DAY
    setTimeout(blastOff, MILLISECONDS_IN_A_DAY);
    ```

* 의미있고 발음하기 쉬운 변수 이름을 사용
    * 안좋은 예 :
    ```
    const yyyymmdstr = moment().format("YYYY/MM/DD");
    ```
    * 좋은 예 :
    ```
    const currentDate = moment().format('YYYY/MM/DD');
    ```
    moment()를 호출하면 현재 날짜와 시각을 얻을 수 있음. 
    format()은 이를 지졍된 형식으로 변환해 줌. 
* 문맥상 필요없는 것들을 불필요하게 반복하지 말 것. 
    * 안좋은 예 :
    ```
    const Car = {
        carMake: "Honda",
        carModel: "Accord",
        carColor: "Blue"
    };
    
    function paintCar(car, color) {
        car.carColor = color;
    }
    ```
    * 좋은 예 : 
    ```
    const Car = {
        Make: "Honda",
        Model: "Accord",
        Color: "Blue"
    };
    
    function paintCar(car, color) {
        car.Color = color;
    }
    ```
***    
5장 형식 맞추기
---
> 기억하고 싶은 책 내용
* 뚜껑을 열었을 때 코드가 깔끔하고, 일관적이고, 꼼꼼하다고 감탄하면 좋겠다. 전문가가 짰다는 인상을 심어주면 좋겠다. 술 취한 뱃사람 한 무리가 짜놓은 듯 어수선해 보인다면 프로젝트의 다른 측면도 똑같이 무성의한 태도로 처리했으리라 생각할 것이다. 
* 형식을 맞추는 목적
    * 오늘 구현한 기능이 다음 버전에서 바뀔 확률은 아주 높다. 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다. 융통성없이 맹목적으로 코드 형식을 따르면 안된다. 원활한 소통을 장려하는 코드 형식은 무엇일까?
* 적절한 길이를 유지
    * 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다. 일반적으로 큰 파일보다 작은 파일이 이해하기 쉽다. 
    * 최대 120자 정도로 행 길이를 제한한다. 
* 신문 기사처럼 작성
    * 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 묘사한다. 마지막에는 가장 저차원 함수와 세부 내역이 나온다. 
* 세로 밀집도
    * 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다. 
* 변수 선언
    * 변수는 사용하는 위치에 최대한 가까이 선언한다.
    * 인스턴스 변수는 클래스 맨 처음에 선언한다. 

***    
6장 객체와 자료구조
---
> 기억하고 싶은 책 내용
* 자료 추상화 : 구현을 감추려면 추상화가 필요하다. 
* 자료/객체 비대칭 
    * 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. 자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.
    * 새로운 함수가 아니라 새로운 자료 타입이 필요한 경우는 객체 지향 기법이 가장 적합하다. 새로운 함수가 필요한 경우는 절차적인 코드와 자료 구조가 적합하다.  
        * 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 
        * 객체지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. 객체지향 코드는 새로운 함수를 추가하기 어렵다. 그러러면 모든 클래스를 고쳐야 한다. 
* 디미터 법칙
    * 기차 충돌
    * 잡종 구조
    * 구조체 감추기
* 자료 전달 객체 
    * 활성 레코드 
> 소감 및 생각
> 새롭게 배운 개념
* 조회 함수
* 설정 함수
* 구현 노출
* 디미터 법칙 [실용주의 프로그래머 참고] : 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙. 
***    
7장 오류 처리
---
> 기억하고 싶은 책 내용
* 깨끗한 코드와 오류 처리는 확실히 연관성이 있다. 오류 처리 코드가 여기저기 흩어지면 실제 코드가 하는 일을 파악하기가 거의 불가능하다. 오류처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다. 
* 오류 코드보다 예외를 사용하라. 
* Try-Catch-Finally문부터 작성하라. 
    * 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법을 권장한다. 그러면 자연스럽게 try 블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다. 
* 미확인 예외를 사용하라. 일반적인 어플리케이션은 의존성이라는 비용이 이익보다 크다. 
* 호출자를 고려해 예외 클래스를 정의하라 
    * 외부 API를 사용할 때는 감싸기 기법이 최선이다. 
* null을 반환하지 마라
    * 메서드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다. 
* null을 전달하지 마라 
    * 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다. 
> 소감 및 생각
* 이번 장에서는 오류처리와 프로그램 논리를 분리하여 코딩해야 깨끗한 코드를 짤 수 있음을 배웠다. 강의들을 들으며 오류처리를 어떻게 하는지 주의깊게 보며 강의 내용을 정리하면 나중에 참고할 일이 있을 듯 하다. 
> 새롭게 배운 개념
* 확인 예외와 미확인 예외
    * 확인 예외 : 컴파일 단계에서 확인되며 반드시 처리해야 하는 예외
    * 미확인 예외 : 실행 단계에서 확인되며 명시적인 처리를 강제하지 않는 예외
        * 미확인 예외의 단점 : 메서드를 선언할 때 메서드가 반환할 예외를 모두 열거해야 하기 때문에 메서드 유형의 일부가 됨. 
* 특수 사례 패턴 : 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식
* 예외 처리 방법
    * throws
    * try - catch - finally