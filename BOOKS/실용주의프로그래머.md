
실용주의 프로그래머
=====

목차
---

1. 추천사&서문
2. 실용주의 철학
3. 실용주의 접근법
4. 기본 도구
5. 실용주의 편집증
6. 구부러지거나 부러지거나
7. 동시성
8. 코딩하는 동안
9. 프로젝트 전에
10. 실용주의 프로젝트
***
추천사&서문
---
1장 실용주의 철학
---
> 소감 및 정리
* 이번 장은 실용주의 개발자로서 지녀야 할 태도에 관한 내용이 담겨있다.
* 그때 그때의 상황에 맞는 최적의 해결방안을 찾기 위해,
* 문제를 어떻게 정의해야 하는지, 그리고 해결방안을 찾는 태도가 어때야 하는지를 설명하고 있다. 
* 3가지로 정리해보면, 자기주도적인 태도, 세심한 관리, 소통력이다. 
* 1. 절대 기계적으로 일하지 말고, 자기 일을 비평하라. 이 일은 이미 엄청난 일정 압박에 시달리고 있을 시간의 일부를 잡아먹을 것이다. 하지만 이 일을 해서 업무에 더 적극적으로 참여할 수 있고, 더 다양한 종류의 일에 숙달될 것이며, 장기적으로 팀은 더 효율적으로 일하게 되고, 회의에 시간을 덜 들이게 될 것이다. 
* 2. 우리는 엔트로피가 이기게 놔두면 안된다. 깨진 창문은 밴드처리라도 해서 상황을 잘 관리하고 있음을 보이고, 지식 포트폴리오를 통해 소량으로라도 주기적으로 우리의 지식 자산을 관리해야 한다. 
* 3. 청중을 알고, 말하려는 말을 정리하고, 멋져보이게 전달하라. 그리고 경청하고 응답하라. 이 모든 것을 문서화해라. 
> 새롭게 배운 개념
* 에이전시 : 주체적으로 원하는 행동을 고르고 행할 수 있는 능력. 개발자들은 다른 대부분 전문직 종사자보다 더 많은 에이전시를 가지고 있다. 
> 기억하고 싶은 책 내용

* 서문  
    * 프로그래밍은 애매모호한 요구사항을 단순한 기계를 활용하여 최대한 구현하려고 노력한다. 
    * 실용주의는 "개별 상황에 맞게 그 상황에 맞는 좋은 해결방안을 고르는 것". 이를 위해서 충분한 배경지식과 경험을 쌓아야 한다.
        * 모든 사람이 자신의 프로그래밍 언어가 최고라고 자랑하고, 모든 운영체제가 자신이 모든 문제를 고칠 수 있는 해답이라고 주장한다. 
        * 도구든, 언어든, 운영체제든 최고의 해결방안 같은 것은 없다. 오직 특정한 환경 조건들만다 가장 적절한 시스템들이 있을 뿐이다. 
    * 무엇이 실용주의 프로그래머를 만드는가?
        * 절대 기계적으로 일하지 말라. 언제나 일하면서 동시에 생각하고, 자기 일을 비평하라. 
            * 이 일은 여러분의 소중한 시간, 이미 엄청난 일정 압박에 시달리고 있을 시간의 일부를 잡아먹을 것이다. 
            * 이 일을 해서 받을 수 있는 보상은, 
            * 여러분이 사랑하는 직업에 더 적극적으로 참여할 수 있는 것, 
            * 점점 더 다양한 종류의 일에 숙달되어 간다는 느낌,
            * 지속적인 발전을 느끼는 데서 오는 기쁨이다. 
            * 장기적으로 보면 여러분의 팀은 더 효율적이 되고, 더 유지 보수하기 쉬운 코드를 작성하게 되고, 회의에 시간을 덜 들이게 될 것이므로 여러분이 투자한 시간은 충분히 보상받게 될 것이다. 
    * 프로젝트의 전체 구조 속에는 언제나 개성과 장인정신을 발휘할 여지가 있다.
        * 우리가 단지 돌을 자를지라도 언제나 대성당을 마음속에 그려야 한다.  
    * 훌륭한 잔디밭은 매일 조금씩 손질해주어야 한다. 
* 1장 실용주의 철학    
    * 실용주의 프로그래머는 무엇이 다른가? 
    * 문제와 해법에 접근하는 태도와 방식, 철학에 차이가 있다.
    * 우리는 스스로 행동을 직접 결정할 수 있는 힘이 있다. 
        * 업무 환경이 엉망인가? 하는 일이 지루한가? 문제를 고치기 위해 노력하라. 하지만 너무 오랫동안 노력하지는 말라. 당신은 당신의 조직을 바꾸거나 당신의 조직을 바꿀 수 있다. 
    * 자신과 자신의 행동에 책임을 져야 한다. 
        * 우리는 자신의 능력에 자부심을 가질 수 있지만, 실수나 무지같은 단점도 인정해야만 한다. 
        * 변명 말고 대안을 제시하라. 안된다고 하지 말고 상황을 개선하기 위해 무엇을 할 수 있는지 설명하라. 
    * 깨진 창문을 밴드처리라도 해서 상황을 잘 관리하고 있음을 보여줘라. 
        * 적절히 고칠 시간이 없다면, 일단 판자로 덮는 것만이라도 하라. 
        * 주석처리하거나, 아직 구현되지 않았음 이라고 메시지를 표시하거나, 가짜 데이터로 대치해 놓거나 하라. 
    * 미래를 살짝이라도 보여주면 사람들은 도와주기 위해 모여들 것이다. 
        * 무엇을 해야 하는지, 어떻게 해야 하는 지 정확히 아는 경우가 있다. 전체 시스템이 눈앞에 뻔히 그려지고, 여러분은 그 시스템이 옳다는 걸 안다.
        * 돌멩이를 내놔야 할 때다. 큰 무리 없이 요구할 수 있을 만한 것을 찾아라. 그리고 그걸 잘 개발하라. 일단 무언가 생기면 사람들에게 보여주고 그들이 경탄하게 하라. 
    * 시스템이 성공하려면 사용자의 요구사항을 충족해야 한다. 
        * 생산해 낸 시스템이 적당히 괜찮게 사용자의 요구를 충족하는지 결정하는 과정에 사용자가 참여할 기회를 가져야 한다. 
        * 기본적인 성능이나 개인 정보 보호, 보안 기준 등.
        * 멈춰야 할 때를 알라. 멈춰야 할 때를 놓치면 고된 작업을 망쳐버릴 수도 있다. 
    * 지식 포트폴리오 
        * 주기적인 투자 : 소량으로라도 주기적으로 투자해야 한다. 
        * 검토 및 재조정. 
    * 소통하라
        * 청중을 알고
        * 말하려는 말을 정리하고
        * 어떻게 전달할지 고르고
        * 멋져보이게 하라
        * 경청하고 응답하라
        * 이 모든것을 문서화하는 것은 중요하다. 
            * 절충안, 결정의 이유, 폐기한 다른 대안 등.
***
2장 실용주의 접근법
---
> 소감 및 정리
- 모든 설계는 의뢰인의 요청으로부터 시작한다. 
- 의뢰인의 요청은 시장상황에 의해 요청은 언제든지 변할 수 있기에, 모든 설계는 기본적으로 바꾸기 쉽게 설계되어야 한다.
    - 바꾸기 쉬우려면 "유지보수"가 쉬워야 하고, "변경 리스크"를 적게 설계해야 한다. 
    - 바꾸기 쉬우면 "생산성"도 높아진다. "개발시간과 테스트 시간"이 줄어들고 "재사용"이 촉진되기 때문이다. 
- 의뢰인과 개발자는 시간이 항상 없기 때문에 빠르고 정확한 소통이 필요하다. 
    - 빠르고, 저렴하게 요청사항과 위험요소를 파악하기위해 프로토타입이 필요하고,
    - 빠르고, 저렴하고, 정확하게 시스템을 구축하기위해 예광탄이 필요하며,
    - 신뢰감을 주기 위해'추정치'를 잘 전달하는 것이 중요하다. 
> 새롭게 배운 개념
- 도메인 언어
    - 문제 도메인에 가깝게 프로그래밍하라
- 추정치는 어디에서 나오는가?
    - 무엇을 묻고 있는지 이해하라
    - 시스템의 모델을 만들어라
    - 모델을 컴포넌트로 나눠라
> 기억하고 싶은 책 내용
* 모든 설계의 핵심 - 바꾸기 더 쉽게  "ETC(Easy to change)"
    * 좋은 설계의 핵심은 모든 차원에 적용가능하다. 모든 것이 여기에 뿌리를 두고 있다. 
    * 아무 실마리가 없을 경우에는 1. 모든 코드를 교체할 수 있게 작성하고, 2. 현재 상황과 개발자의 선택, 그리고 변경사항에 대한 추측을 정리해두고, 이후 직관을 발전시킨는 기회로 삼아라. 나중에 그 코드를 바꿔야 하는 시점이 왔을 때 뒤를 돌아보고 자신에게 피드백을 주어라. 그러면 비슷한 갈림길에 다시 섰을 때 도움이 될 것이다.
* 중복의 해악 -  유지보수가 쉬우려면 중복하지  마라 DRY(Don’t Repeat Yourself)
    * 개발자는 대부분의 시간을 유지보수를 하며 보낸다.
    - 소프트웨어를 신뢰성 있게 개발하고 개발을 유지보수하기 쉽게 만드는 유일한 길은 반복하지 않는것이다.
        - 코드의 중복
        - 표현상의 중복
        - 개발자 간의 중복
- 직교성  - 영향력을 최소화하여
    - 직교성이란, 하나가 바뀌어도 나머지에 어떤 영향을 주지 않는 것이다.
    - 직교적인 시스템은 "변경과 조정"이 쉽다.
        - 자신의 힘으로 제어할 수 없는 속성에 의존하지 말라.
    - 직교적인 시스템은 "생산성"을 향상시킨다.
        - 개발시간과 테스트 시간이 줄어들고 재사용도 촉진한다.
    - 직교적인 시스템은 "리스크"를 감소시킨다.
        - 어떤 모듈이 병에 걸려도 시스템의 나머지 부분으로 증상이 전파될 확률이 낮다.
- 가역성 - 유연한 구조
    - 유연하고 적응가능한 소프트웨어를 만드는 방법에 초점을 맞춰라. 
        - 결정이 돌에 새겨진 것이 아니라 바닷가의 모래 위에 쓰인 글씨라 생각하라.
        - 되돌릴 수 없는 결정을 줄여야 하는 까닭은 우리가 프로젝트 초기에 늘 최선의 결정을 내리지는 못하기 때문이다.
- 예광탄 - 빠르고, 저렴하고, 정확하게
    - 예광탄이 효과적인 까닭은 일반 탄환과 동일한 환경 및 제약 조건에서 발사되기 때문이다. 탄환이 순식간에 목표물에 도달하기 때문에 기관총 사수는 즉각적인 피드백을 얻을 수 있다. 실용적인 관점에서 봐도 예광탄은 상대적으로 비용이 적게든다.
    - 시스템을 정의하는 중요한 요구사항을 찾아라. 이런 부분의 코드를 가장 먼저 작성하도록 개발 우선순위를 정하라.
    - 예광탄이 언제나 목표물을 맞히는 것은 아니다. 하지만 적어도 빠르고 저렴하게 더 정확한 버전을 만들 수 있을 것이다. 사용자는 지금 보고 있는 것이 단지 종이에 쓰인 명세가 아니라 현실에 기반을 두고 있다는 확신을 얻을 수 있다.
    - 예광탄은 기능은 별로 없지만 완결된 코드이며 최종 시스템 골격 중 일부가 된다. 프로토 타입은 나중에 버리는 코드를 만든다. 프로토 타입은 예광탄을 발사하기 전에 먼저 수행하는 정찰이나 정보수집같은 것이다.
- 프로토타입과 포스트잇
    - 프로토타이핑의 가치는 생산한 코드에 있는 것이 아니라 이를 통해 배우는 교훈에 있다. 
    - 위험요소를 분석하고 노출시킨 후, 이를 매우 저렴한 비용으로 바로잡을 기회를 얻기 위해 만든다. 
- 도메인 언어
    - 실용주의 프로그래머는 언제나 애플리케이션 도메인의 어휘를 사용해서 코드를 작성하려 노력한다. 
- 추정
    - 추정하기 전에 미리 어떤 조건이 있을지 생각하는 습관을 길러야 한다. 
    - 의뢰인의 요청을 이해한 후에는 간단하게 모델을 만들어보라. 프로젝트의 발판이 될 뿐 아니라 시스템을 어떻게 구혀해야 할지 밑그림을 줄 것이다. 
***
3장 기본도구
---
> 소감 및 정리
- 업무를 더 똑똑하게 일할 수 있는 도구들을 설명해주고 있다. 
    - 엔지니어링 일지 파트에서는 현재 기록중인 깃허브와 블로그를 좀 더 발전시킬 수 있을 것 같다. 
        - 무언가를 쓰기 시작하면 하던 일을 되돌아볼 수 있는 기회가 생긴다. 
        - 하루하루 내가 어떤 작업들을 하고 있는지 되돌아보는 시간을 10분이라도 가진다면 불필요한 작업들을 덜어낼 수 있을 것이다. 
    - 추후 들을 강의리스트에 깃 활용법, 리눅스 강의를 추가해야겠다.
    - 파일 저장 방법을 선택할 때 추후 수정용이성을 고려하면 더 효율적으로 일할 수 있을 것이다. 
> 새롭게 배운 개념
- 셸
    - 리눅스의 셸 : 명령어와 프로그램을 실행할 때 사용하는 인터페이스. 커널에서 분리된 별도의 프로그램.
- 에디팅
    - 단축키를 통해 반복적인 작업을 최소화해라
- 텍스트 파일과 이진 파일
    - 텍스트 파일
        - 문자로 구성된 파일. 대부분 아스키 문자로 이뤄진 파일이나 사람이 사용하는 문장들로 이뤄진 파일. README.txt, 소스코드 파일(.cpp) 등
    - 이진 파일
        - 데이터로 구성된 파일. 모든 파일은 0과1로 이루어짐. 이미지파일(.png), 데이터파일(.dat),실행파일(.exe) 등
> 기억하고 싶은 책 내용
- 일반 텍스트의 힘
    - 이진 형식과 비교하여, 일반 텍스트는 버전관리,확장성,수정에 용이하다. 
- 셸 가지고 놀기
    - GUI는 훌륭하지만, 일반적으린 작업을 자동화할 수 없고, 가용한 도구의 역량을 온전히 사용할 수 없다. 도구를 결합해서 자신에게 꼭 맞는 '매크로 도구'를 만들 수 없다. 
- 파워 에디팅
    - 자신이 에디터를 사용하는 모습을 관찰하라. 무언가 같은 일을 반복하는 것을 발견할 때마다 이렇게 생각하는 습관을 들여라. '분명 더 나은 방법이 있을 텐데.' 그리고 더 나은 방법이 있는지 찾아보라. 
- 버전 관리
    - 버전 관리 시스템은 일종의 거대한 '실행 취소' 키와 같다. 프로젝트 전체에 걸쳐서 코드가 실제로 컴파일되고 실행되던 지난주의 평화로운 시절로 돌려줄 수 있는 타임머신이다. 
- 디버깅
    - 디버깅은 많은 개발자들에게 예민하고 감성적인 주제다. 디버깅을 풀어야할 퍼즐로 공략하는 대신 현실 부정이나 손가락질, 어설픈 변명, 무관심으로 대하는 사람과 마주치기도 한다. 버그가 누구의 잘못인지는 중요치 않다. 어쨌거나 그 버그를 해결해야 하는 사람은 개발자이다. 
    - 디버깅을 할 때 겉으로 드러난 특정한 증상만 고치려고 하지 말고, 항상 문제의 근본 원인을 찾으려고 노력하라. 
- 텍스트 처리
    - 텍스트 처리언어를 사용해서 유틸리티를 뚝딱 만들어낼 수도 있고, 아이디어를 프로토타입해 볼 수도 있다. 전통적인 언어를 사용하면 다섯배에서 열배 가까이 더 오래 걸릴 것이다. 
- 엔지니어링 일지
    - 일지는 기억보다 더 믿을 만하다. 
    - 진행 중인 작업과 직접적인 관계가 없는 발상을 일단 쌓아놓을 수 있다. 위대한 발상을 잊어버릴 걱정 없이 지금 하는 일에 계속 집중할 수 있다. 
    - 무언가를 쓰기위해 하던 일을 멈추면 뇌도 기어를 바꾼다. 하던 일을 돌아보기에 알맞은 기회가 생기는 것이다. 
