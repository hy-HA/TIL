# 1. Bean Validation
- 검증 로직을 모든 프로젝트에 적용할 수 있게 공통화하고, 표준화 한 것
    - 검증 애노테이션과 여러 인터페이스의 모음
    - 특정한 구현체가 아니라 Bean Validation 2.0(JSR-380)이라는 기술 표준
    - Bean Validation을 구현한 기술중에 일반적으로 사용하는 구현체는 하이버네이트 Validator
1. 의존관계 추가
    - 'org.springframework.boot:spring-boot-starter-validation'

# 스프링 MVC는 어떻게 Bean Validator를 사용?
1. 스프링 부트 
    1. spring-boot-starter-validation 라이브러리를 설정
        - 자동으로 Bean Validator를 인지하고 스프링에 통합한다.
    2. 자동으로 글로벌 Validator로 등록
        - LocalValidatorFactoryBean 을 글로벌 Validator로 등록
            - 이 Validator는 @NotNull 같은 애노테이션을 보고 검증을 수행
            이렇게 글로벌 Validator가 적용되어 있기 때문에, 
    3. 검증할 컨트롤러에 @Valid 혹은 @Validated 적용
        - 글로벌 Validator가 @Valid 혹은 @Validated 적용된 컨트롤러에서 @NotNull 같은 애노테이션을 보고 검증을 수행
2. 글로벌 Validator(LocalValidatorFactoryBean) (공룡같은 놈)
    1. 검증 오류가 발생하면, FieldError , ObjectError 를 생성해서 BindingResult 에 담아준다
        1. @ModelAttribute 각각의 필드에 타입 변환 시도 
            1. 성공하면 2번으로
            2. 실패하면 typeMismatch 로 FieldError 추가 
        2. Validator 적용
    2. 참고
        - 바인딩에 성공한 필드만 Bean Validation 적용
            - BeanValidator는 바인딩에 실패한 필드는 BeanValidation을 적용하지 않는다.
            - 생각해보면 타입 변환에 성공해서 바인딩에 성공한 필드여야 BeanValidation 적용이 의미 있다.
# Bean Validation이 기본으로 제공하는 오류 메시지를 좀 더 자세히 변경하기

1. Bean Validation을 적용하고 bindingResult 에 등록된 검증 오류 코드를 보자.
    ```
    if(bindingResult.hasErrors()){
        log.info("errors={}", bindingResult);
        return "validation/v3/addForm";
    }
    ```
    - 오류 코드가 애노테이션 이름으로 등록된다. 마치 typeMismatch 와 유사
    - NotBlank 라는 오류 코드를 기반으로 MessageCodesResolver 를 통해 다양한 메시지 코드가 순서대로 생성
    ```
    @NotBlank
        NotBlank.item.itemName 
        NotBlank.itemName 
        NotBlank.java.lang.String 
        NotBlank
    @Range
        Range.item.price 
        Range.price 
        Range.java.lang.Integer 
        Range
    ```
2. 메시지 등록
- errors.properties
    - {0} 은 필드명이고, {1} , {2} ...은 각 애노테이션 마다 다르다.
```
#Bean Validation 추가 
NotBlank={0} 공백X 
Range={0}, {2} ~ {1} 허용 
Max={0}, 최대 {1}
```
- BeanValidation 메시지 찾는 순서
    1. 생성된 메시지 코드 순서대로 messageSource 에서 메시지 찾기
        - NotBlank.item.itemName 
        - NotBlank={0} 공백X 
    2. 애노테이션의 message 속성 사용 
        - @NotBlank(message = "공백! {0}") 
    3. 라이브러리가 제공하는 기본 값 사용 
        - 공백일 수 없습니다.

# Bean Validation에서 특정 필드( FieldError )가 아닌 해당 오브젝트 관련 오류( ObjectError )는 어떻게 처리할 수 있을까?

- @ScriptAssert() 를 사용
```
@Data
@ScriptAssert(lang = "javascript", script = "_this.price * _this.quantity >=
10000")
    public class Item {
    //...
}
```

- 메시지 코드
    ScriptAssert.item
    ScriptAssert

- 그런데 실제 사용해보면 제약이 많고 복잡하다. 그리고 실무에서는 검증 기능이 해당 객체의 범위를 넘어서는 경우들도 종종 등장하는데, 그런 경우 대응이 어렵다.

- 따라서 오브젝트 오류(글로벌 오류)의 경우 @ScriptAssert 을 억지로 사용하는 것 보다는 다음과 같이 오브젝트 오류 관련 부분만 직접 자바 코드로 작성하는 것을 권장

```
@PostMapping("/add")
public String addItem(@Validated @ModelAttribute Item item, BindingResult
bindingResult, RedirectAttributes redirectAttributes) {

    //특정 필드 예외가 아닌 전체 예외
    if (item.getPrice() != null && item.getQuantity() != null) {
        int resultPrice = item.getPrice() * item.getQuantity();
    if (resultPrice < 10000) {
        bindingResult.reject("totalPriceMin", new Object[]{10000,
resultPrice}, null);
    }

    if (bindingResult.hasErrors()) {
        log.info("errors={}", bindingResult);
        return "validation/v3/addForm";
    } 

}
```
