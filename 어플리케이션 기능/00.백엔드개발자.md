# 1️⃣ API 설계 
- 프런트가 보고 잘 개발할 수 있도록 지원을 잘 해줘야(표준구현 해야)

- 🟨 HTTP 김영한 강의 들을 것


## REST API 구성
1. 자원(resource) - URI
2. 행위(verb) - HTTP Method
3. 표현(representations)
    ```
    [엔드포인트 구성]
    - 메소드와 URI정보로 판단
        
    DELETE /subject/{id}
    GET    /subject
    GET    /subject/{id}
    POST   /subject
    PATCH  /grade/{id}/score

    => 통일성 가져야
    => 엔드포인트만 보고 유추가 되어야
    ```

## REST API 디자인 가이드
1. URI는 정보의 자원을 표현해야
    ```
    [잘못된 예 (x)]

    GET /members/delete/1

    ㄴ URI는 delete와 같은 행위에 대한 표현이 들어가면 안됨
    ```
2. 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현
    - PUT : 모든 정보 수정 시 
    - PATCH: 일부 정보 수정 시 
    ```
    [올바른 예 (o)]

    DELETE /memebers/1

    ㄴ 자원에 대한 행위는 HTTP Method로 표현
    ```

# 2️⃣ 문제를 해결하는 과정

## 2-1. 찾으려는 객체에 유니크한 컬럼이 없으면 객체 조회시 문제가 된다
- 과목을 같은 값으로 중복생성하면 grade 객체 조회시 오류 발생
    ```
    과목 생성
        {id:1, "ENG"}
        {id:2, "ENG"} 

    grade 생성로직

        //과목 조회 : subject는 기존에 있는 것인지 확인
        subjectRepository.findBySubjectType(gradeForm.getSubjectType())

        >> "ENG"가 2개라 오류발생
    }
    ```
    - 해결방안
        1. limit으로 1개만 검색되도록 한다
            - 과부하가 걸릴 수 있음
        2. 중복생성이 되지 않도록 막는다
            ```
            @Column(unique = true)
            private SubjectType subjectType
            ```
## 2-2. request폼이 상황에 따라 달라야 하는 경우
- grade를 등록할 때와 수정할 때 보여야 하는 값이 다름
    ```
    1. grade 등록

        private String studentName;
        private String subjectName;
        private Integer score;


    2. grade 수정

        private Integer score;
    ```
    - 해결방안
        1. 클래스를 별도로 관리
            - 단점 : 관리할 클래스가 늘어남
            - 주의 : 새로운 클래스가 생기면 기존 코드가 바뀔 수 있음
                - 기존 : GradeForm
                - 신규 : UpdateGradeForm
                    - GradeForm > CreateGradeForm 으로 바뀌어야
            - 장점 : 클래스가 분리되어 비즈니스 관계를 논리적으로 끊을 수 있음. 
                - 다른 클래스가 변경이 된다고 영향을 받지 않는다. 
        2. innerClass
            - 주의 : static으로 해야(자바 문법)
            - 껍데기 클래스를 만들고 그 안에 각각의 클래스를 만들어 관리