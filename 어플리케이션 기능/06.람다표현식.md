# builder
- 필드가 많을 때(보통 3개 이상) 사용
- 명확하게 어느 순서에 어느 변수가 있는지 알 수 있음. 

## 사용법
1. builder()로 시작, build()로 끝.

## builder 메소드 생성해보기
- return this 하는 이유
	- 자기자신으로 되돌려서 .을 찍을 수 있도록 하기 위해.
```
public class ScoreResponse {
    private String studentName;
    private Double score;

    public static ScoreResponseBuilder builder() {
        return new ScoreResponseBuilder();
    }

    public static class ScoreResponseBuilder {
        private String studentName;
        private Double score;

        public ScoreResponseBuilder studentName(String studentName) {
            this.studentName = studentName;
            return this;
        }

        public ScoreResponseBuilder score(Double score) {
            this.score = score;
            return this;
        }

        public ScoreResponse build() {
            return new ScoreResponse(studentName, score);
        }
    }
}
```
- 서비스에서 builder 사용하기 
1. builder()는 static메소드
	- static이 아니면 클래스를 생성해야 함
		```
		ScoreResponse sr = new ScoreResponse();
		```
```
ScoreResponse.builder()
	.score(student.getStudentAverageScore())
	.studentName(student.getName())
	.build();
```

## AtomicInteger, AtomicLong

```
for(String st : Str){
	System.out.print(index++);
}
```

- 위 처럼 반복문이 돌 때마다 인덱스를 증가or감소 하여 처리하는 로직을 함수형 프로그래밍에서 사용하고 싶을 때가 있다.

- 하지만, 람다 표현식 내부에서는 final이나 final처럼 동작하는 (immutable) 숫자가 들어가지 않으면 아래와 같은 에러를 뱉는다.

```
sample.stream().forEach(x -> x.getSeq + i++); // Error
Variable used in lambda expression should be final or effectively final
```

- 이럴 때 사용하는 게 AtomicInteger, AtomicLong 이다.

```
AtomicInteger counter = new AtomicInteger(0);

sample
	.stream()
	.forEach(x -> x.getSeq + counter.getAndIncrement()); 현재 값을 가져온 뒤 1 증가
```
