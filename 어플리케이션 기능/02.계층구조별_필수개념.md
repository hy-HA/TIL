# 계층구조별_필수개념
[도메인](#도메인)
[리포지토리](#리포지토리)
[서비스](#서비스)
[컨트롤러](#컨트롤러)
[DTO](#dto)

# 도메인
<details>
<summary><b> ✅ 도메인 </b></summary>
<div markdown="1">

## 1. Setter는 사용하지 말 것
[참고](https://velog.io/@backfox/setter-%EC%93%B0%EC%A7%80-%EB%A7%90%EB%9D%BC%EA%B3%A0%EB%A7%8C-%ED%95%98%EA%B3%A0-%EA%B0%80%EB%B2%84%EB%A6%AC%EB%A9%B4-%EC%96%B4%EB%96%A1%ED%95%B4%EC%9A%94)

1. 도메인 로직의 분산되는 것을 막기 위해
2. 객체 필드값을 수정하는 목적에 맞게 메서드를 정의하기 위해

## 2. 생성자보다 정적 팩토리 메소드를 고려하라
```
public static Test of(Student student, Subject subject){
    Test test = new Test();
    test.subject = subject;
    test.student = student;
    return test;
}
```

## 3. 롬복

- @Entity 
    - 해당 클래스를 DB테이블과 매핑
- @Table(name="student") 
    - 엔티티와 매핑할 테이블을 지정
- @NoArgsConstructor 
    - 파라미터가 없는 기본 생성자 생성
- @Id @GeneratedValue 
    - 기본키를 DB가 생성해주는 값으로 사용
    
- @Column(name = "student_id")
    - 객체 필드를 테이블 컬럼과 매핑(name: 필드외 매핑할 테이블 컬럼명 지정)
- @OneToMany(mappedBy = "student", cascade = CascadeType.ALL) 
    - 해당필드(test) 테이블에 있는 student필드에 의해 매핑됨.(변경x, 읽기전용)
    
- @Builder
    - 객체를 정의하고 그 객체를 생성하는 방법
    - 장점
        1. 생성자 파라미터가 많을 때 가독성이 좋음
        2. 어떤 값을 먼저 설정하던 상관이 없다
    - 사용법
        1. 빌더 패턴을 적용할 객체에 @Builder 어노테이션 선언
        2. 빌더를 통해 객체 생성

## enum타입
- 존재하지 않는 과목명이 insert되지 않도록
[참고](https://www.opentutorials.org/module/1226/8025)
### 1. 선언하기 
### 1. java파일로 선언
- 선언 시 열거형 상수를 다른 값과 연결하기
    - KOR, MATH, ENG : 상수(수식에서 변하지 않는 값)
```
SubjectType.java>>

public enum SubjectType {
    //열거형 상수를 다른 값과 연결하기
    KOR("국어", 1), MATH("수학", 2), ENG("영어", 3);

    private String description;
    private int value;

    //enum에서 생성자 같은 역할
    SubjectType(String description, int value) {
        this.value = value;
        this.description = description;
    }

}
```
### 2. Subject 엔티티 클래스의 속성으로 사용하기
- EnumType.ORDINAL : enum 순서 값을 DB에 저장
- EnumType.STRING : enum 이름을 DB에 저장
```
Subject.java>>

@Enumerated(value = EnumType.STRING)
private SubjectType subjectType;

@Builder
public Subject(String subject, int score){
    initSubjectType(subject);
    this.score = score;
}

// 디미터 법칙 적용해서 .을 하나만 찍도록 하자
public String getSubjectType() {
        return subjectType.name();
    }

private void initSubjectType(String subject) {
    try {
        this.subjectType = SubjectType.valueOf(subject);
    } catch (IllegalArgumentException e) {
        // 첫번째 방법
        //this.subjectType = SubjectType.UNREGISTER;

        // 2번째 방법
        throw TypeException.of("과목", subject);
    }
}
```
### 클래스에서 사용하기
```
SubjectResponse.java>>

public SubjectResponse(Subject subject) {
        this.id = subject.getId();

        this.subject = subject.getSubjectType();
    }
```

### 메소드
1. values() 
    - 열거된 모든 원소를 배열에 담아 순서대로 반환
2. valueOf() 
    - 매개변수로 주어진 String과 열거형에서 일치하는 이름을 갖는 원소를 반환
        - 대소문자 구분함
        - 정의된 타입만 사용가능
    - 주어진 String과 일치하는 원소가 없는 경우 IllegalArgumentException 예외 발생)
```
<값 가져오는 방법>

* enum 형 객체를 만들어서 값 가져오기
ex) Type.WALKING
* valueOf() 메소드를 이용해서 가져오기
ex) Type.valueOf("WALKING");
```
## 참고 - 의존성 주입의 3가지 방법
- 등록된 빈을 사용하기 위한 스프링 프레임워크의 3가지 DI방법

### 생성자 주입
> 추천하는 이유
1. 순환참조를 방지할 수 있음 - 순환 참조가 발생하는 경우 애플리케이션이 구동되지 않음
2. 테스트 코드 작성 용이 - 단순 POJO를 이용한 테스트 코드 만들 수 있음
3. 코드 속 나쁜 내새를 없앤다? - 조금 더 품질좋은 코드 작성 가능
4. immutable하다 - 실행중에 객체가 변하는 것을 막을 수 있음 & 오류를 사전에 방지가능
```
// 단일 생성자인 경우는 추가적인 어노테이션이 필요 없다.
public MadExample(HelloService helloService) {
    this.helloService = helloService;
}
```
### 필드 주입
```
@Autowired private HelloService helloService;
```
### 수정자 주입
```
@Autowired
public void setHelloService(HelloService helloService) {
    this.helloService = helloService;
}
```

</details>


# 리포지토리

<details>
<summary><b> ✅ 리포지토리 </b></summary>


## 1. JpaRepository 상속받기
- JPA리포지토리를 사용하면 옵셔널로 받아옴. 
- 반환값이 옵셔널. 옵셔널을 하나의 컬렉션이라 생각하면됨. 


## 2. 옵셔널
- Optional.orElseThrow()


## 3. 익셉션
### 3-1.런타임 익셉션
- 해당 익셉션이 발생하는 경우
    - 배열에 index값 넘어설때
    - 널 발생
- => 익셉션이 발생하면 롤백마크가 찍힘 > 상위에까지 전달됨.

### 3-2.일반 익셉션
- 에러잡을때 try catch로 잡아야

## 4. 커스텀 익셉션

## 5. 🟨 쿼리 메소드
- 필드명과 동일하게 설정해야
    ```
    [SubjectRepository.java]

    public interface SubjectRepository extends JpaRepository<Subject, Long> {

    Optional<Subject> findBySubjectType(SubjectType subjectType);
    }

    
    [subject.java]

    private Long id;
    private SubjectType subjectType;
    private int score;
    
    >> subject에 subjectType을 찾는경우 리포지토리에서 변수명을 subject의 필드명과 동일하게 설정해야
    ```
</details>


# 서비스


<details>
<summary><b> ✅ 서비스 </b></summary>

## 필드주입보다는 생성자 주입
```
@Autowired StudentRepository studentRepository; 보다는
private final StudentRepository studentRepository; 으로
```

## 비즈니스 로직 생성

### 답변용 학생계정(StudentResponse) 생성
```
@Transactional
public StudentResponse createStudent(StudentRequest request) {
    Student student = Student.builder()
            .name(request.getName())
            .score(request.getScore())
            .build();

    return new StudentResponse(studentRepository.save(student));
}
```

### 답변용 학생계정(StudentResponse) 리스트 조회
```
@Transactional(readOnly = true)
public List<StudentResponse> getStudentList() {
    List<StudentResponse> result = new ArrayList<>();
    for (Student student : studentRepository.findAll()) {
        result.add(new StudentResponse(student));
    }

    return result;

    /*return studentRepository.findAll()
            .stream()
            .map(StudentResponse::new)
            .collect(Collectors.toList());*/
}
```
### 답변용 학생계정(StudentResponse) 조회
```
@Transactional(readOnly = true)
public StudentResponse getStudent(Long id) {
    Student student = studentRepository.findById(id)
            .orElseThrow(() -> DomainException.notFoundRow(id));

    return new StudentResponse(student);
}
```


</details>

# 컨트롤러

<details>
<summary><b> ✅ 컨트롤러 </b></summary>

## 컨트롤러의 특징
1. 파라미터에 어노테이션을 붙여야
    - @RequestBody
    - @PathVariable
2. 주소를 알려줘야 
    - @PatchMapping("/grade/{id}/score)

## RestController vs controller
1. @Controller의 역할
    - 뷰에 표시될 데이터가 있는 Model 객체를 만들고 올바른 뷰를 선택하는 일을 담당
    - @ResponseBody를 사용
        - HTTP Response Body에 데이터를 담아 요청을 완료할 수 있음
        - RESTful 웹 서비스에 대한 응답에 매우 유용
        - 왜냐하면 뷰를 반환하는 대신 데이터를 반환하기 때문
2. @RestController
    - @Controller와 @ResponseBody의 조합
    - RESTful 웹 서비스를 보다 쉽게 개발할 수 있도록 Spring 4.0에서 추가
    - 단순히 객체만을 반환하고 객체 데이터는 JSON 또는 XML 형식으로 HTTP 응답에 담아서 전송
- responsebody : 바디에 데이터를 바로 전달 가능. 

## ResponseEntity
- HttpEntity를 상속받고 사용자의 응답 데이터가 포함된 클래스라 아래를 포함
    1. HttpStatus
    2. HttpHeaders
        - status 코드(200,400 등)
    3. HttpBody
        - 응닶값

- 자동으로 객체를 넣었을때 state코드 응답값을 통일된 형태로 보내주는 

## 람다식 
- stream
</details>


# DTO
- 화면페이지에서 요구사항이 계속 바뀌니 도메인에서 필요한 부분만 받아오기위해

<details>
<summary><b> ✅ DTO </b></summary>

## @Data 
- @Getter, @Setter, @RequiredArgsConstructor, @ToString, @EqualsAndHashCode을 한꺼번에 설정

## @AllArgsConstructor
- 모든 필드값을 파라미터로 받는 생성자 생성
## @NoArgsConstructor
- 파라미터가 없는 기본 생성자 생성
## @RequiredArgsConstructor
- final이나 @NonNull인 필드 값만 파라미터로 받는 생성자 생성


### DTO request와 response 두개로 관리. 왜?

- 너는 어떤 도메인에서 일해? 
    - A : 이커머스, 금융권, 보안 
    - A-1 : 상품을 관리하는/주문/결제

- 장점
    - 변경사항이 생겼을 때 같은 객체를 쓰게되면 다 같이 변경이 됨
    - 의존성을 끊어주는 것이 중요. 
    - DDD 개념이 그래서 나오게 된 것. 

- 단점
    - dto 객체가 많아지면, 레이어가 많아지면, 변환로직(컨트롤러에서 서비스로 넘어갈때)
    - 컨버터 비용이 늘어난다. A객체에서 B객체로 변환하는 로직
    - mapstruct
</details>
