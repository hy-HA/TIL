| https://sehajyang.github.io/2020/04/15/springboot-envers-logging-for-revision/

# Audit

## JPA Audit 배경
- 도메인들이 공통적으로 가지고 있는 필드나 컬럼들이 존재 
    - 대표적으로 생성일자(입수, 승인), 수정일자, 식별자 같은 필드
- 데이터베이스에서 누가, 언제하였는지 기록을 잘 남겨놓아야 함
- 생성일, 수정일 컬럼은 대단히 중요한 데이터
- 그래서 JPA에서는 Audit이라는 기능을 제공

## Audit
- 감시하다, 감사하다라는 뜻
- Spring Data JPA에서 시간에 대해서 자동으로 값을 넣어주는 기능
- 도메인을 영속성 컨텍스트에 저장하거나 조회를 수행한 후에 update를 하는 경우 매번 시간 데이터를 입력하여 주어야 하지만
- audit을 이용하면 자동으로 시간을 매핑하여 데이터베이스의 테이블에 넣어주게 됨

### 의존성 추가
```
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
```
### TimeEntity.java
- @MappedSuperclass 
    - JPA Entity클래스들이 해당 추상 클래스를 상속할 경우 해당 필드들을 컬럼으로 인식
- @EntityListeners(AuditingEntityListener.class)
    - 해당 클래스에 Auditing 기능을 포함
- @CreatedDate
    - Entity가 생성되어 저장될 때 시간이 자동 저장
- @LastModifiedDate
    - 조회한 Entity의 값을 변경하 ㄹ때 시간이 자동 저장
```
@Getter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class TimeEntity {

    @CreatedDate
    private LocalDateTime createdDate;

    @LastModifiedDate
    private LocalDateTime modifiedDate;
```
### 클래스 상속
1. Study 클래스가 @MappedSuperclass가 적용된 TimeEntity 추상 클래스를 상속
    - JPA가 생성일자, 수정일자 컬럼을 인식하게 됨 
2. 영속성 컨텍스트에 저장 후 TimeEntity 클래스의 Auditing 기능으로 인해서 트랜잭션 커밋 시점에 플러시가 호출할 때 하이버네이트가 자동으로 시간 값을 채워줌
```
@Getter
@NoArgsConstructor
@Entity
public class Study extends TimeEntity {

}
```

### JPA Auditing 활성화
- 스프링 부트의 Entry 포인트인 실행 클래스에 @EnableJpaAuditing 어노테이션을 적용하여 JPA Auditing을 활성화
```
@EnableJpaAuditing
@SpringBootApplication
public class BoardApplication {

	public static void main(String[] args) {
		SpringApplication.run(BoardApplication.class, args);
	}

}
```

# envers
- envers는 hibernate 에서 만든 데이터 변경 이력을 로깅하기 위한 라이브러리
- 과거
    - 로깅을 위해 customer_hist 와 같은 엔티티를 정의하고 customer 에 insert, update, delete 등의 작업이 발생하면,
    - history 테이블에도 같은 작업을 해줘야 했으며, 이력을 쌓아야 하는 테이블이 늘어날 수록 이러한 번거로운 반복작업을 계속해야했습니다.
- 그러나 envers를 사용하면 이러한 번거로운 작업을 대폭 줄일 수 있습니다.
    - 기본적으로 jpa로 구현되어있으며 후에 spring에도 spring data envers 프로젝트로 추가되었습니다.
    - spring data envers 역시 hibernate에서 관리하기 때문에 큰 차이는 없습니다.

### 의존성 추가
```
implementation 'org.springframework.data:spring-data-envers'
```

### property config 설정
- audit_table_suffix
    - auditing table의 prefix, suffix를 수정
- revision_field_name 
    - revision fk 로 쓰는 테이블들의 revid 바꾸고 싶은 경우 설정할 수 있지만 테이블마다 각각 rev_id를 따로 설정하는 것은 불가능합니다. (order_rev_id, product_rev_id 이렇게 개별로 설정 불가능)
- delete 시 aud 테이블에서 타겟 테이블의 pk 만 쌓을뿐 다른 필드의 값은 기본적으로 null 입니다.
    - null이 아니라 delete 직전의 모든 필드의 값을 쌓고 싶다면 store_data_at_delete: true 를 설정
- 더 많은 property config는 Envers Configuration Properties에서 확인
```
spring:
    jpa:
      org:
        hibernate:
          envers:
            audit_table_suffix: _log
            revision_field_name: rev_id
            store_data_at_delete: true
```

### @Audited로 변경이력 저장할 테이블 설정
1. @Audited(targetAuditMode = NOT_AUDITED)
2. @AuditOverride(forClass = BaseEntity.class)
    -  extends 한 엔티티의 이력도 추가되길 원한다면 @AuditOverride(forClass=BaseEntity.class) 도 추가
3. 추적하지 않을 필드
    - @NotAudited 추가
4. 그러면 기본적으로 총 두개의 테이블이 생성됨
    - customer 엔티티의 상단에 @Audited를 추가하면 revinfo, customer_aud 테이블이 생성됨
        1. revinfo
            - central revision table 로, 최초 1회만 생성되며, 이 revinfo 테이블을 삭제하거나 disable 할 순 없습니다. 
            - 네이밍 및 필드 변경은 가능
            - rev 필드의 네이밍 변경을 각 테이블마다 다르게 줄 수 없습니다.
        2. entity_aud 테이블
            - rev_type필드는 int타입으로 생성, 수정, 삭제를 구분하는 컬럼
            - 타입, 필드명, 값을 변경할 순 없음
            - 0 : insert
            - 1 : update
            - 2 : delete
5. rev 컬럼의 타입
- central revision table인 revinfo의 pk인 rev 컬럼의 타입은 기본적으로 int 로 되어있음
- 데이터가 20억개 이상 넘어가면 오류가 발생하므로, 권남님 포스팅의 [REV 를 long 으로 변경해야한다]처럼 int 타입을 long 타입으로 변경해줘야
```
@Entity
@Audited(targetAuditMode = NOT_AUDITED)
public class Student extends BaseEntity {
    ...

    @NotAudited
    @Column(unique = true)
    private String residentNumber;

}
```
### 그 외
1. 테이블이 서로 연관관계인 경우 추적 테이블을 만들지 않을 경우
    - 연관관계 추적 테이블 생성은 되지만 추적하진 않을거라면 
    - 연관관계 테이블 생성도 하지 않고 추적하지도 않을거라면 
2. 양방향관계에선 AuditMappedBy로 관계 명시를 해줘야
3. 상속관계에 있는 테이블도 audit 하고싶은 경우
4. queryDSL과 함께 쓰면 조회시 호환이 되지 않는 문제가 발생

[참고](https://sehajyang.github.io/2020/04/15/springboot-envers-logging-for-revision/)

<br>
<br>

# AOP
- 로그를 수동으로 찍다 보면 아래와 같은 문제가 생김
1. 중복된 코드의 증가
2. 실수로 로그를 찍지 않으면 값 확인 불가능
- 따라서 AOP를 사용해 요청이 오면 요청 데이터, 응답 데이터, 요청까지 걸린 시간을 로그로 자동으로 찍어주는 코드를 작성해보도록 하겠습니다.

### @EnableAspectJAutoProxy 설정
- @SpringBootApplication이 있는 클래스에 @EnableAspectJAutoProxy 추가

```
@EnableAspectJAutoProxy
@SpringBootApplication
public class BoardApplication {
}
```

### @Aspect 클래스 만들기
- @Around
    - 대상 객체(within으로 범위 설정 가능)의 메서드 실행 전, 후 시점에 메소드를 실행
- ProceedingJoinPoint
    - 호출되는 객체에 대한 정보, 실행될 메소드에 대한 정보가 존재
- getRequestAttributes
    - 호출된 값의 Request 값을 얻을 때 사용, 없으면 null 반환
    - currentRequestAttributes와 비슷하지만 currentRequestAttributes는 값이 없으면 예외 발생
- proceed()
    - 메소드 실행
- 전체 흐름
    1. 조인포인트의 메소드 추출
    2. 메소드의 오퍼레이션과 getMapping어노테이션 추출
    3. 컨트롤러와 메소드의 이름, 반환 값의 로그 출력
    4. 메소드 실행
```
@Slf4j
@Aspect
@Component
public class RequestLoggingAspect {

    @Around(value = "restController() && getMapping()")
    public Object query(ProceedingJoinPoint joinPoint) {

        //(1)조인포인트의 메소드 추출
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();

        //(2) 메소드의 오퍼레이션과 getMapping어노테이션 추출
        Operation operation = method.getAnnotation(Operation.class);
        GetMapping getMapping = method.getAnnotation(GetMapping.class);

        Object result;

        //(3) 컨트롤러와 메소드의 이름, 반환 값의 로그 출력
        //(4) 메소드 실행
        try {
            log.error(operation.summary());
            log.error(Arrays.toString(getMapping.value()));
            result = joinPoint.proceed();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }

        return result;
    }

    @Pointcut("@annotation(org.springframework.web.bind.annotation.GetMapping)")
    protected void getMapping() {
    }

    @Pointcut("@within(org.springframework.web.bind.annotation.RestController)")
    protected void restController() {
    }
}
```

# AuditRevision
### AuditRevision 생성
```
@NoArgsConstructor
@Getter
@Entity
@RevisionEntity
@Table(name = "revision")
public class AuditRevision {

    @RevisionNumber
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "rev")
    private Long id;

    @RevisionTimestamp
    @Column(name = "revstamp")
    private Long timestamp;


    /**
     *
     */
    @Column(name = "admin_id")
    private Long adminId = 0L;

}
```
### AuditRevisionListener

```
public class AuditRevisionListener implements RevisionListener {
    @Override
    public void newRevision(Object revisionEntity) {
        AuditRevision revision = (AuditRevision) revisionEntity;

        revision.putAdminId(Long.parseLong(MDC.get("adminId")));
        revision.putOperation(MDC.get("operation"));

        MDC.clear();
    }
}
```