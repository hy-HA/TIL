# soft delete 와 hard delete

# hard delete
```
@Transactional
public void deleteStudent(Long id) {

    studentRepository.deleteById(id);     

}
```

# soft delete 
- 도메인에서 delete 컬럼 설정
## 1. 확장받을 BaseEntity 생성 
- BaseEntity 어노테이션
    1. @Getter
    2. @MappedSuperclass 
    3. @EntityListeners(AuditingEntityListener.class) 🟨
    [개념정리](https://hackmd.io/YpHn8z9xQOiqfyUK226_eQ)
```
@Getter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public class BaseEntity {

    @CreatedDate
    private LocalDateTime createdDate;

    @LastModifiedDate
    private LocalDateTime modifiedDate;

    //🧩상속받는 클래스들이 사용하려면? 
    //protected가 최선? private는? public은?
    protected Boolean isDeleted;

    public void delete() {
        this.isDeleted = true;
    }

}
```
## 2. 확장하는 Student 도메인에서 where 어노테이션 사용
### @Where(clause = "is_deleted = false")
- 역할 🟨
    - BaseEntity에서 정의한 delete()메소드를 확장하는도메인.delete()로 사용가능하게 함. 
```
@Getter
@NoArgsConstructor
@Entity
@Table(name="student")
@Where(clause = "is_deleted = false")
// @SQLDelete(sql = "update student set is_deleted = true where student_id = ?")
public class Student extends BaseEntity {

    @Id @GeneratedValue
    @Column(name = "student_id")
    private Long id;

    private String name;

    private int score;

    @Builder
    public Student(String name, int score){
        this.name = name;
        this.score = score;
        this.isDeleted = false;
    }
```

## 3. 서비스에서 삭제기능 사용
- 옵셔널의 예외처리 
```
@Transactional
public void deleteStudent(Long id) {
    
    //(1) hard delete
    studentRepository.deleteById(id);     

    //(2) soft delete
    Student student = studentRepository.findById(id)
                .orElseThrow(() -> DomainException.notFoundRow(id));
    student.delete();   
}
```

## 4. 컨트롤러에서 설정
### 컨트롤러의 특징
1. 파라미터에 어노테이션을 붙여야
    - @RequestBody
    - @PathVariable
2. 주소를 알려줘야 
    - @PatchMapping("/grade/{id}/score)
3. 컨트롤러 에노테이션
    - @ResponseBody
    - @RequiredArgsConstructor
    - @RequestMapping("/student")
### @PathVariable
- 삭제의 경우 파라미터로 id값을 받으므로 @RequestBody가 아니라 @PathVariable
```
@ResponseBody
    @DeleteMapping("/{id}")
    public ResponseEntity<StudentResponse> deleteStudent(@PathVariable Long id) {
        studentService.deleteStudent(id);
        return ResponseEntity.status(HttpStatus.NO_CONTENT).build();
    }
```

## @MappedSuperclass
- 객체의 입장에서 공통 매핑정보가 필요할 때 사용
- @MappedSuperclass가 선언되어 있는 클래스는 엔티티가 아니다. 
    - 당연히 테이블과 매핑도 안된다. 
    - 단순히 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공한다.
- 직접 생성해서 사용할 일이 없으므로 추상 클래스로 만드는 것을 권장함
- 해당 어노테이션이 붙은 클래스는 모든 Entity의 상위 클래스가 됨
    - Entity 들의 createdDate, modifiedDate를 자동으로 관리하는 역할
- @MappedSuperclass 
    - JPA Entity 클래스들이 해당 클래스를 상속할 경우 필드들(createdDate, modifiedDate)도 칼럼으로 인식하도록 함
- @EntityListeners(AuditingEntityListener.class)
    - BaseTimeEntiy 클래스에 Auditing 기능을 포함시킵니다.
- @CreatedDate
    - Entity가 생성되어 저장될 때 시간이 자동 저장됩니다.
- @LastModifiedDate
    - 조회한 Entity의 값을 변경할 때 시간이 자동 저장됩니다.

```java
@Getter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseTimeEntity {

    @CreatedDate
    private LocalDateTime createdDate;

    @LastModifiedDate
    private LocalDateTime modifiedDate;

}
```
## Application 클래스
- JPA Auditing 어노테이션들을 모두 활성화할 수 있도록 Application 클래스에 활성화 어노테이션을 추가합니다.
- @EnableJpaAuditing: JPA Auditing을 활성화 하기 위한 어노테이션입니다.
```java
@EnableJpaAuditing
@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(CaffeineApplication.class, args);
    }
}
```
