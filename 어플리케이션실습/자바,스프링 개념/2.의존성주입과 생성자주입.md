스프링 개념정리 > 의존성주입과 스프링부트 동작방식 참고

# 의존성 주입
- 의존하는 부분을 외부에서 주입하는 것. 
    - 의존하는 부분 
        - '사용하는 객체' 클래스에 '사용되는 객체' 클래스가 작성된 상태
    - 외부로부터 주입 
        - '사용하는 객체' 클래스의 밖에서 '사용되는 객체' 인스턴스를 주입

## 의존성 주입의 3가지 방법
- 등록된 빈을 사용하기 위한 스프링 프레임워크의 3가지 DI방법
    1. 필드 주입
        - 필드 주입을 이용하면 코드가 간결해져서 과거에 상당히 많이 이용되었던 주입 방법
        - 하지만 필드 주입은 외부에서 접근이 불가능하다는 단점이 존재
        - 테스트 코드의 중요성이 부각됨에 따라 필드의 객체를 수정할 수 없는 필드 주입은 거의 사용되지 않게 되었다. 
        - 또한 필드 주입은 반드시 DI 프레임워크가 존재해야 하므로 반드시 사용을 지양해야 한다. 
        ```
        @Service
        public class UserService {

            @Autowired private UserRepository userRepository;
            @Autowired private MemberService memberService;

        }
        ```
    2. 생성자 주입
        - 생성자의 호출 시점에 1회 호출 되는 것이 보장된다. 
            - 그렇기 때문에 주입받은 객체가 변하지 않거나, 
            - 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용할 수 있다. 
        - 또한 Spring 프레임워크에서는 생성자 주입을 적극 지원하고 있기 때문에, 
            - 생성자가 1개만 있을 경우에 @Autowired를 생략해도 주입이 가능하도록 편의성을 제공하고 있다. 
        ```
        @Service
        public class UserService {

            private UserRepository userRepository;
            private MemberService memberService;

            @Autowired
            public UserService(UserRepository userRepository, MemberService memberService) {
                this.userRepository = userRepository;
                this.memberService = memberService;
            }
            
        }
        ```
    3. 수정자 주입
        - setter는 지양해야


## 생성자 주입 추천하는 이유 
[참고](https://mangkyu.tistory.com/125)
1. 객체의 불변성(immutable) 확보
    - 실행중에 객체가 변하는 것을 막을 수 있음 & 오류를 사전에 방지가능
    - 실제로 개발을 하다 보면 의존 관계의 변경이 필요한 상황은 거의 없다. 
        - 하지만 수정자 주입이나 일반 메소드 주입을 이용하면 불필요하게 수정의 가능성을 열어두어 유지보수성을 떨어뜨린다. 
        - 그러므로 생성자 주입을 통해 변경의 가능성을 배제하고 불변성을 보장하는 것이 좋다.
2. 테스트 코드의 작성 용이
    - 단순 POJO를 이용한 테스트 코드 만들 수 있음
3. final 키워드 작성 및 Lombok과의 결합
4. 스프링에 비침투적인 코드 작성
5. 순환 참조 에러 방지
    - 순환 참조가 발생하는 경우 애플리케이션이 구동되지 않음

### 수정자 주입 지양하는 이유
- 공개 set 메서드를 사용할 때 도메인 로직이 한 곳에 응집되지 않으므로 코드를 유지 보수할 때에도 분석하고 수정하는 데 더 많은 시간이 필요하다
1. 도메인 로직이 분산되는 것을 막기 위해
2. 객체 필드값을 수정하는 목적에 맞게 메서드를 정의하기 위해
    -  [참고](https://velog.io/@backfox/setter-%EC%93%B0%EC%A7%80-%EB%A7%90%EB%9D%BC%EA%B3%A0%EB%A7%8C-%ED%95%98%EA%B3%A0-%EA%B0%80%EB%B2%84%EB%A6%AC%EB%A9%B4-%EC%96%B4%EB%96%A1%ED%95%B4%EC%9A%94)

## 리포지토리 선언 시 제너럴 타입을 명시하지 않으면 모든 빈의 주입이 실패함


![](https://i.imgur.com/f0ZWlJa.png)

- UnsatisfiedDependencyException Error creating bean with name 'studentController' defined in file [~~StudentController.class] : Unsatisfied dependency expressed through constructor parameter 0;
    - 동일한 에러가 서비스, 리포지토리에 발생
```
public interface StudentRepository extends JpaRepository<Student, Long> {}

>> <Student, Long>을 명시하지 않으면 어플 실행 안됨
```