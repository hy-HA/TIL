# 의존성 주입

### setter는 사용하지 말 것
1. 도메인 로직이 분산되는 것을 막기 위해
2. 객체 필드값을 수정하는 목적에 맞게 메서드를 정의하기 위해
    -  [참고](https://velog.io/@backfox/setter-%EC%93%B0%EC%A7%80-%EB%A7%90%EB%9D%BC%EA%B3%A0%EB%A7%8C-%ED%95%98%EA%B3%A0-%EA%B0%80%EB%B2%84%EB%A6%AC%EB%A9%B4-%EC%96%B4%EB%96%A1%ED%95%B4%EC%9A%94)
## 의존성 주입의 3가지 방법
- 등록된 빈을 사용하기 위한 스프링 프레임워크의 3가지 DI방법
- [의존성주입](https://hackmd.io/R4xP8rDAQbG8sC2tJrdO0g)
    1. 필드 주입
        - [참고 : 상속과 컴포지션](https://hackmd.io/ax72ukQsTbWsVRO2qun29Q) 
    2. 생성자 주입
    3. 수정자 주입


## 생성자 주입
- 추천하는 이유
1. 순환참조를 방지할 수 있음 - 순환 참조가 발생하는 경우 애플리케이션이 구동되지 않음
2. 테스트 코드 작성 용이 - 단순 POJO를 이용한 테스트 코드 만들 수 있음
3. 코드 속 나쁜 냄새를 없앤다? - 조금 더 품질좋은 코드 작성 가능
4. immutable하다 - 실행중에 객체가 변하는 것을 막을 수 있음 & 오류를 사전에 방지가능
```java
// 단일 생성자인 경우는 추가적인 어노테이션이 필요 없다.
public MadExample(HelloService helloService) {
    this.helloService = helloService;
}
```
## 필드 주입
```
@Autowired private HelloService helloService;
```
## 수정자 주입
```
@Autowired
public void setHelloService(HelloService helloService) {
    this.helloService = helloService;
}
```

## 리포지토리 선언 시 제너럴 타입을 명시하지 않으면 모든 빈의 주입이 실패함


![](https://i.imgur.com/f0ZWlJa.png)

- UnsatisfiedDependencyException Error creating bean with name 'studentController' defined in file [~~StudentController.class] : Unsatisfied dependency expressed through constructor parameter 0;
    - 동일한 에러가 서비스, 리포지토리에 발생
```
public interface StudentRepository extends JpaRepository<Student, Long> {}

>> <Student, Long>을 명시하지 않으면 어플 실행 안됨
```